<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clinical Trials Outcomes Visualization</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Chart.js Plugins -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/2.1.0/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <!-- Papa Parse for CSV handling -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <!-- Lodash for data manipulation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <style>
        .chart-container {
            position: relative;
            width: 100%;
            height: 500px;
            margin-bottom: 2rem;
        }
        .mini-chart-container {
            position: relative;
            height: 250px;
            margin-bottom: 1rem;
        }
        .fullscreen-chart {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 50;
            background-color: white;
            padding: 2rem;
        }
        .trial-card {
            transition: all 0.3s ease;
        }
        .trial-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        /* Custom loader */
        .loader {
            border-top-color: #3498db;
            -webkit-animation: spinner 1.5s linear infinite;
            animation: spinner 1.5s linear infinite;
        }
        @-webkit-keyframes spinner {
            0% { -webkit-transform: rotate(0deg); }
            100% { -webkit-transform: rotate(360deg); }
        }
        @keyframes spinner {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Tooltip style */
        .custom-tooltip {
            position: absolute;
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            z-index: 10;
            max-width: 300px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        /* Switch styling */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #4F46E5;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #4F46E5;
        }
    </style>
</head>
<body class="bg-gray-50 font-sans">
    <div class="container mx-auto p-4 sm:p-6">
        <header class="mb-8 text-center">
            <h1 class="text-3xl font-bold mb-2 text-gray-800">Clinical Trials Outcomes Visualization</h1>
            <p class="text-gray-600">Upload JSON files to visualize and compare clinical trial outcomes</p>
        </header>

        <!-- File Upload Section -->
        <div class="mb-8 bg-white rounded-lg shadow-md p-6">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">Upload Clinical Trial JSON Files</h2>
            <p class="text-gray-600 mb-4">Select multiple JSON files (up to 30) to analyze and visualize trial outcomes.</p>
            
            <div class="flex flex-col sm:flex-row gap-4">
                <div class="flex-grow">
                    <input type="file" id="jsonFiles" multiple accept=".json" class="w-full text-sm text-gray-500
                        file:mr-4 file:py-2 file:px-4
                        file:rounded-md file:border-0
                        file:text-sm file:font-semibold
                        file:bg-blue-50 file:text-blue-700
                        hover:file:bg-blue-100"/>
                </div>
                <button id="processFiles" class="px-6 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition-colors">
                    Process Files
                </button>
            </div>
            
            <!-- Processing Status -->
            <div id="processingStatus" class="mt-4 hidden">
                <div class="flex items-center">
                    <div class="loader ease-linear rounded-full border-4 border-t-4 border-gray-200 h-5 w-5 mr-3"></div>
                    <span id="statusText" class="text-blue-600">Processing files...</span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2.5 mt-2">
                    <div id="progressBar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- Navigation tabs for different views -->
        <div id="navigationTabs" class="mb-6 hidden">
            <div class="border-b border-gray-200">
                <nav class="-mb-px flex space-x-8">
                    <button id="tabOverview" class="tab-button border-indigo-500 text-indigo-600 whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm">
                        Overview
                    </button>
                    <button id="tabComparison" class="tab-button border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm">
                        Compare Trials
                    </button>
                    <button id="tabDetailed" class="tab-button border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm">
                        Detailed View
                    </button>
                </nav>
            </div>
        </div>

        <!-- Overview Section -->
        <div id="overviewSection" class="mb-8 hidden">
            <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                <h2 class="text-xl font-semibold mb-4 text-gray-700">Trials Overview</h2>
                <div id="trialsOverview" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <!-- Trial cards will be added here -->
                </div>
            </div>
            
            <!-- Overall Success Rate Chart -->
            <div id="overviewChartSection" class="bg-white rounded-lg shadow-md p-6">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-semibold text-gray-700">Outcomes Overview</h2>
                    <div class="flex items-center space-x-4">
                        <select id="overviewMetric" class="text-sm border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                            <option value="successRate">Success Rate</option>
                            <option value="completion">Completion Rate</option>
                            <option value="enrollment">Enrollment</option>
                        </select>
                        <button id="toggleOverviewChartView" class="px-3 py-1 bg-gray-100 text-gray-700 rounded hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-300 text-sm">
                            <span class="flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
                                </svg>
                                Fullscreen
                            </span>
                        </button>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="overviewChart"></canvas>
                </div>
            </div>
        </div>
        
        <!-- Comparison Section -->
        <div id="comparisonSection" class="mb-8 hidden">
            <div class="bg-white rounded-lg shadow-md p-6">
                <h2 class="text-xl font-semibold mb-4 text-gray-700">Compare Trials</h2>
                
                <div class="mb-6">
                    <h3 class="text-lg font-medium mb-2 text-gray-700">Select Trials to Compare</h3>
                    <div id="trialSelectors" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <!-- Trial checkboxes will be added here -->
                    </div>
                </div>
                
                <div class="mb-6">
                    <h3 class="text-lg font-medium mb-2 text-gray-700">Select Outcome Measure</h3>
                    <select id="outcomeSelector" class="w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                        <!-- Outcome options will be added here -->
                    </select>
                </div>
                
                <div id="comparisonChartContainer" class="hidden">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-medium text-gray-700">Comparison Chart</h3>
                        <button id="toggleComparisonView" class="px-3 py-1 bg-gray-100 text-gray-700 rounded hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-gray-300 text-sm">
                            <span class="flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
                                </svg>
                                Fullscreen
                            </span>
                        </button>
                    </div>
                    <div class="chart-container">
                        <canvas id="comparisonChart"></canvas>
                    </div>
                    <div class="mt-4 p-4 bg-gray-50 rounded-md text-sm text-gray-700">
                        <h4 class="font-semibold mb-2">Notes:</h4>
                        <ul class="list-disc pl-5 space-y-1" id="comparisonNotes">
                            <!-- Notes will be added here -->
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Detailed View Section -->
        <div id="detailedSection" class="hidden">
            <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                <h2 class="text-xl font-semibold mb-4 text-gray-700">Trial Details</h2>
                
                <div class="mb-6">
                    <label for="detailedTrialSelector" class="block text-sm font-medium text-gray-700 mb-2">Select Trial</label>
                    <select id="detailedTrialSelector" class="w-full border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                        <!-- Trial options will be added here -->
                    </select>
                </div>
                
                <div id="trialDetailsContainer" class="hidden">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                        <div>
                            <h3 class="text-lg font-medium mb-2 text-gray-700">Trial Information</h3>
                            <div id="trialInfo" class="bg-gray-50 p-4 rounded-md">
                                <!-- Trial info will be added here -->
                            </div>
                        </div>
                        <div>
                            <h3 class="text-lg font-medium mb-2 text-gray-700">Study Design</h3>
                            <div id="studyDesign" class="bg-gray-50 p-4 rounded-md">
                                <!-- Study design info will be added here -->
                            </div>
                        </div>
                    </div>
                    
                    <h3 class="text-lg font-medium mb-2 text-gray-700">Outcome Measures</h3>
                    <div id="outcomeAccordion" class="space-y-2">
                        <!-- Outcome accordion items will be added here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- No Data Message -->
        <div id="noDataMessage" class="hidden text-center py-12">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mx-auto text-gray-400 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <h3 class="text-xl font-medium text-gray-700 mb-2">No Valid Data Found</h3>
            <p class="text-gray-500" id="noDataReason">The uploaded files don't contain valid clinical trial data. Please check your files and try again.</p>
        </div>

        <!-- Fullscreen Chart Modal -->
        <div id="fullscreenModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center overflow-auto">
            <div class="bg-white rounded-lg p-6 w-11/12 h-5/6 max-w-6xl">
                <div class="flex justify-between items-center mb-4">
                    <h2 id="fullscreenChartTitle" class="text-xl font-semibold">Chart Detail View</h2>
                    <button id="closeFullscreen" class="text-gray-500 hover:text-gray-700">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <div class="h-full">
                    <canvas id="fullscreenChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Alert Toast -->
        <div id="alertToast" class="hidden fixed top-4 right-4 z-50 max-w-xs bg-white rounded-lg shadow-lg overflow-hidden">
            <div class="p-4">
                <div class="flex items-start">
                    <div id="alertIcon" class="flex-shrink-0">
                        <!-- Icon will be added dynamically -->
                    </div>
                    <div class="ml-3 w-0 flex-1 pt-0.5">
                        <p id="alertTitle" class="text-sm font-medium text-gray-900"></p>
                        <p id="alertMessage" class="mt-1 text-sm text-gray-500"></p>
                    </div>
                    <div class="ml-4 flex-shrink-0 flex">
                        <button id="closeAlert" class="inline-flex text-gray-400 hover:text-gray-500">
                            <svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
            <div id="alertProgress" class="bg-blue-600 h-0.5"></div>
        </div>
    </div>

    <script type="module">
        /**
         * Clinical Trials Visualization - Main Module
         */
        
        // Import modules
        import { TrialData } from './modules/TrialData.js';
        import { ChartManager } from './modules/ChartManager.js';
        import { UIManager } from './modules/UIManager.js';
        
        // Main application initialization
        document.addEventListener('DOMContentLoaded', () => {
            const app = new ClinicalTrialsApp();
            app.initialize();
        });
        
        class ClinicalTrialsApp {
            constructor() {
                this.trialsData = [];
                this.uiManager = new UIManager();
                this.chartManager = new ChartManager();
                this.processedFiles = 0;
                this.totalFiles = 0;
                this.selectedOutcome = null;
                this.selectedTrials = new Set();
                this.currentView = 'overview';
            }
            
            initialize() {
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                // Process files button
                document.getElementById('processFiles').addEventListener('click', this.handleProcessFiles.bind(this));
                
                // Tab navigation
                document.getElementById('tabOverview').addEventListener('click', () => this.switchView('overview'));
                document.getElementById('tabComparison').addEventListener('click', () => this.switchView('comparison'));
                document.getElementById('tabDetailed').addEventListener('click', () => this.switchView('detailed'));
                
                // Fullscreen buttons
                document.getElementById('toggleOverviewChartView').addEventListener('click', () => {
                    this.chartManager.openFullscreenChart('overviewChart', 'Outcomes Overview');
                });
                
                document.getElementById('toggleComparisonView').addEventListener('click', () => {
                    this.chartManager.openFullscreenChart('comparisonChart', 'Trials Comparison');
                });
                
                // Close fullscreen button
                document.getElementById('closeFullscreen').addEventListener('click', () => {
                    this.chartManager.closeFullscreenChart();
                });
                
                // Alert close button
                document.getElementById('closeAlert').addEventListener('click', () => {
                    this.uiManager.hideAlert();
                });
                
                // Overview metric selector
                document.getElementById('overviewMetric').addEventListener('change', (e) => {
                    this.updateOverviewChart(e.target.value);
                });
                
                // Detailed trial selector
                document.getElementById('detailedTrialSelector').addEventListener('change', (e) => {
                    this.showTrialDetails(e.target.value);
                });
                
                // Outcome selector for comparison
                document.getElementById('outcomeSelector').addEventListener('change', (e) => {
                    this.selectedOutcome = e.target.value;
                    this.updateComparisonChart();
                });
            }
            
            handleProcessFiles() {
                const files = document.getElementById('jsonFiles').files;
                if (files.length === 0) {
                    this.uiManager.showAlert('Please upload at least one JSON file.', 'error');
                    return;
                }
                
                if (files.length > 30) {
                    this.uiManager.showAlert('Please upload no more than 30 files.', 'error');
                    return;
                }
                
                // Reset state
                this.trialsData = [];
                this.processedFiles = 0;
                this.totalFiles = files.length;
                this.selectedTrials = new Set();
                this.uiManager.clearResults();
                this.chartManager.destroyAllCharts();
                
                // Show processing status
                this.uiManager.showProcessingStatus();
                
                // Process each file
                Array.from(files).forEach(this.processFile.bind(this));
            }
            
            processFile(file) {
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    try {
                        const jsonData = JSON.parse(e.target.result);
                        const trialData = new TrialData(jsonData, file.name);
                        
                        if (trialData.isValid()) {
                            this.trialsData.push(trialData);
                        }
                    } catch (error) {
                        console.error(`Error processing file ${file.name}:`, error);
                        this.uiManager.showAlert(`Error processing file ${file.name}: ${error.message}`, 'error');
                    }
                    
                    this.processedFiles++;
                    this.uiManager.updateProgress(this.processedFiles, this.totalFiles);
                    
                    // Check if all files have been processed
                    if (this.processedFiles === this.totalFiles) {
                        this.completeProcessing();
                    }
                };
                
                reader.onerror = () => {
                    this.uiManager.showAlert(`Failed to read file ${file.name}`, 'error');
                    this.processedFiles++;
                    this.uiManager.updateProgress(this.processedFiles, this.totalFiles);
                    
                    if (this.processedFiles === this.totalFiles) {
                        this.completeProcessing();
                    }
                };
                
                reader.readAsText(file);
            }
            
            completeProcessing() {
                this.uiManager.hideProcessingStatus();
                
                if (this.trialsData.length > 0) {
                    // Sort trials by ID for consistency
                    this.trialsData.sort((a, b) => a.id.localeCompare(b.id));
                    
                    // Initialize UI with data
                    this.uiManager.showNavigationTabs();
                    this.setupOverviewSection();
                    this.setupComparisonSection();
                    this.setupDetailedSection();
                    
                    // Show overview by default
                    this.switchView('overview');
                } else {
                    this.uiManager.showNoDataMessage("None of the uploaded files contained valid clinical trial data with results. Please ensure your JSON files contain trial results data.");
                }
            }
            
            switchView(view) {
                this.currentView = view;
                this.uiManager.switchView(view);
                
                // If the chart needs updating after tab change
                if (view === 'overview') {
                    this.updateOverviewChart(document.getElementById('overviewMetric').value);
                } else if (view === 'comparison') {
                    this.updateComparisonChart();
                }
            }
            
            setupOverviewSection() {
                // Create trial overview cards
                this.uiManager.createTrialOverviewCards(this.trialsData);
                
                // Create initial overview chart
                this.updateOverviewChart('successRate');
            }
            
            updateOverviewChart(metric) {
                const chartData = {
                    labels: this.trialsData.map(trial => trial.id),
                    datasets: []
                };
                
                if (metric === 'successRate') {
                    // Gather primary outcomes success rates
                    chartData.datasets.push({
                        label: 'Primary Outcome Success Rate',
                        data: this.trialsData.map(trial => {
                            const primaryOutcomes = trial.getOutcomesByType('PRIMARY');
                            if (primaryOutcomes.length === 0) return null;
                            
                            // Calculate average success rate across primary outcomes
                            return primaryOutcomes.reduce((sum, outcome) => {
                                // Use endpoint value for success rate
                                const endpointValues = outcome.getEndpointValues();
                                if (!endpointValues || endpointValues.length === 0) return sum;
                                
                                // For each group, calculate improvement from baseline or just use final value
                                const groupValues = endpointValues.map(ev => {
                                    const baselineValue = outcome.getBaselineValue(ev.group);
                                    if (baselineValue !== null) {
                                        // Calculate percent improvement
                                        const change = ev.value - baselineValue;
                                        const percentChange = (baselineValue !== 0) ? 
                                            (change / Math.abs(baselineValue)) * 100 : 0;
                                        
                                        // Invert if lower is better
                                        return outcome.isLowerBetter ? -percentChange : percentChange;
                                    }
                                    return ev.value; // No baseline, just use value
                                });
                                
                                // Average across groups
                                return sum + (groupValues.reduce((a, b) => a + b, 0) / groupValues.length);
                            }, 0) / primaryOutcomes.length;
                        }),
                        backgroundColor: this.trialsData.map(trial => {
                            // Color based on trial status
                            const status = trial.status.toUpperCase();
                            if (status === 'COMPLETED') return 'rgba(34, 197, 94, 0.7)';
                            if (status === 'TERMINATED') return 'rgba(239, 68, 68, 0.7)';
                            if (status === 'WITHDRAWN') return 'rgba(156, 163, 175, 0.7)';
                            return 'rgba(59, 130, 246, 0.7)'; // Default blue
                        }),
                        borderColor: this.trialsData.map(trial => {
                            const status = trial.status.toUpperCase();
                            if (status === 'COMPLETED') return 'rgb(22, 163, 74)';
                            if (status === 'TERMINATED') return 'rgb(220, 38, 38)';
                            if (status === 'WITHDRAWN') return 'rgb(107, 114, 128)';
                            return 'rgb(37, 99, 235)'; // Default blue
                        }),
                        borderWidth: 1
                    });
                    
                    // Update chart
                    this.chartManager.createSuccessRateChart('overviewChart', chartData);
                } else if (metric === 'completion') {
                    // Gather completion rates
                    chartData.datasets.push({
                        label: 'Completion Rate (%)',
                        data: this.trialsData.map(trial => trial.getCompletionRate()),
                        backgroundColor: 'rgba(34, 197, 94, 0.7)',
                        borderColor: 'rgb(22, 163, 74)',
                        borderWidth: 1
                    });
                    
                    // Update chart
                    this.chartManager.createCompletionRateChart('overviewChart', chartData);
                } else if (metric === 'enrollment') {
                    // Gather enrollment numbers
                    chartData.datasets.push({
                        label: 'Participants Enrolled',
                        data: this.trialsData.map(trial => trial.enrollment),
                        backgroundColor: 'rgba(59, 130, 246, 0.7)',
                        borderColor: 'rgb(37, 99, 235)',
                        borderWidth: 1
                    });
                    
                    // Target enrollment if available
                    const trialWithTarget = this.trialsData.some(trial => trial.targetEnrollment > 0);
                    if (trialWithTarget) {
                        chartData.datasets.push({
                            label: 'Target Enrollment',
                            data: this.trialsData.map(trial => trial.targetEnrollment > 0 ? trial.targetEnrollment : null),
                            backgroundColor: 'rgba(168, 85, 247, 0.3)',
                            borderColor: 'rgb(147, 51, 234)',
                            borderWidth: 1
                        });
                    }
                    
                    // Update chart
                    this.chartManager.createEnrollmentChart('overviewChart', chartData);
                }
            }
            
            setupComparisonSection() {
                // Create trial checkboxes
                this.uiManager.createTrialSelectors(this.trialsData, (trialId, checked) => {
                    if (checked) {
                        this.selectedTrials.add(trialId);
                    } else {
                        this.selectedTrials.delete(trialId);
                    }
                    this.updateComparisonChart();
                });
                
                // Create outcome selector
                this.createOutcomeSelector();
            }
            
            createOutcomeSelector() {
                const outcomeSelector = document.getElementById('outcomeSelector');
                outcomeSelector.innerHTML = '';
                
                // Get all unique outcomes across trials
                const allOutcomes = new Map();
                
                this.trialsData.forEach(trial => {
                    trial.outcomes.forEach(outcome => {
                        // Create a comparison key based on outcome type and name
                        const key = `${outcome.type}-${outcome.title}`;
                        if (!allOutcomes.has(key)) {
                            allOutcomes.set(key, {
                                key: key,
                                type: outcome.type,
                                title: outcome.title,
                                frequency: 1
                            });
                        } else {
                            const existing = allOutcomes.get(key);
                            existing.frequency++;
                        }
                    });
                });
                
                // Sort by frequency (most common first) and then by type
                const sortedOutcomes = Array.from(allOutcomes.values())
                    .sort((a, b) => {
                        if (a.frequency !== b.frequency) return b.frequency - a.frequency;
                        if (a.type !== b.type) {
                            if (a.type === 'PRIMARY') return -1;
                            if (b.type === 'PRIMARY') return 1;
                        }
                        return a.title.localeCompare(b.title);
                    });
                
                // Create option groups
                const primaryGroup = document.createElement('optgroup');
                primaryGroup.label = 'Primary Outcomes';
                
                const secondaryGroup = document.createElement('optgroup');
                secondaryGroup.label = 'Secondary Outcomes';
                
                // Add options to appropriate groups
                sortedOutcomes.forEach(outcome => {
                    const option = document.createElement('option');
                    option.value = outcome.key;
                    option.textContent = outcome.title;
                    
                    if (outcome.type === 'PRIMARY') {
                        primaryGroup.appendChild(option);
                    } else {
                        secondaryGroup.appendChild(option);
                    }
                });
                
                // Add groups to selector
                if (primaryGroup.children.length > 0) {
                    outcomeSelector.appendChild(primaryGroup);
                }
                
                if (secondaryGroup.children.length > 0) {
                    outcomeSelector.appendChild(secondaryGroup);
                }
                
                // Set initial selected outcome
                if (sortedOutcomes.length > 0) {
                    this.selectedOutcome = sortedOutcomes[0].key;
                    outcomeSelector.value = this.selectedOutcome;
                }
            }
            
            updateComparisonChart() {
                if (!this.selectedOutcome || this.selectedTrials.size === 0) {
                    document.getElementById('comparisonChartContainer').classList.add('hidden');
                    return;
                }
                
                // Parse outcome key to get type and title
                const [outcomeType, ...titleParts] = this.selectedOutcome.split('-');
                const outcomeTitle = titleParts.join('-');
                
                // Get matching outcomes from selected trials
                const matchingOutcomes = [];
                this.trialsData.forEach(trial => {
                    if (this.selectedTrials.has(trial.id)) {
                        const outcome = trial.outcomes.find(o => 
                            o.type === outcomeType && o.title === outcomeTitle);
                        
                        if (outcome) {
                            matchingOutcomes.push({
                                trialId: trial.id,
                                outcome: outcome
                            });
                        }
                    }
                });
                
                if (matchingOutcomes.length === 0) {
                    document.getElementById('comparisonChartContainer').classList.add('hidden');
                    return;
                }
                
                // Check if outcomes have time-based data or single values
                const hasTimeData = matchingOutcomes.some(item => 
                    item.outcome.valuesByTime && Object.keys(item.outcome.valuesByTime).length > 0);
                
                if (hasTimeData) {
                    this.createTimeSeriesComparisonChart(matchingOutcomes);
                } else {
                    this.createSimpleComparisonChart(matchingOutcomes);
                }
                
                // Add notes about the chart
                this.addComparisonNotes(matchingOutcomes);
                
                // Show the chart container
                document.getElementById('comparisonChartContainer').classList.remove('hidden');
            }
            
            createTimeSeriesComparisonChart(matchingOutcomes) {
                // Gather all time points across all outcomes
                const allTimePoints = new Set();
                matchingOutcomes.forEach(item => {
                    if (item.outcome.valuesByTime) {
                        Object.keys(item.outcome.valuesByTime).forEach(time => allTimePoints.add(time));
                    }
                });
                
                // Get trial groups
                const trialGroups = new Map();
                matchingOutcomes.forEach(item => {
                    const groups = new Set();
                    if (item.outcome.valuesByTime) {
                        Object.values(item.outcome.valuesByTime).forEach(timeData => {
                            timeData.forEach(measurement => groups.add(measurement.group));
                        });
                    }
                    trialGroups.set(item.trialId, Array.from(groups));
                });
                
                // Sort time points (try to handle numeric and text-based time points)
                const timePoints = Array.from(allTimePoints).sort((a, b) => {
                    // Try to extract numeric values for comparison
                    const aNum = parseFloat(a.match(/(\d+)/) ? a.match(/(\d+)/)[0] : a);
                    const bNum = parseFloat(b.match(/(\d+)/) ? b.match(/(\d+)/)[0] : b);
                    
                    if (!isNaN(aNum) && !isNaN(bNum)) return aNum - bNum;
                    return a.localeCompare(b);
                });
                
                // Create datasets for each trial and group
                const datasets = [];
                const colors = [
                    'rgba(59, 130, 246, 0.7)', // Blue
                    'rgba(234, 88, 12, 0.7)',  // Orange
                    'rgba(16, 185, 129, 0.7)', // Green
                    'rgba(168, 85, 247, 0.7)', // Purple
                    'rgba(239, 68, 68, 0.7)',  // Red
                    'rgba(245, 158, 11, 0.7)'  // Amber
                ];
                
                matchingOutcomes.forEach((item, trialIndex) => {
                    const trialId = item.trialId;
                    const outcome = item.outcome;
                    const groups = trialGroups.get(trialId) || [];
                    
                    groups.forEach((group, groupIndex) => {
                        // Generate data points for each time point
                        const data = timePoints.map(time => {
                            const timeData = outcome.valuesByTime?.[time];
                            if (!timeData) return null;
                            
                            const measurement = timeData.find(m => m.group === group);
                            if (!measurement) return null;
                            
                            return measurement.value;
                        });
                        
                        // Create dataset
                        const colorIndex = (trialIndex * groups.length + groupIndex) % colors.length;
                        datasets.push({
                            label: `${trialId} - ${group}`,
                            data: data,
                            backgroundColor: colors[colorIndex],
                            borderColor: colors[colorIndex].replace('0.7', '1'),
                            borderWidth: 2,
                            fill: false,
                            tension: 0.1
                        });
                    });
                });
                
                // Create chart data
                const chartData = {
                    labels: timePoints,
                    datasets: datasets
                };
                
                // Get unit of measure from first outcome
                const unitOfMeasure = matchingOutcomes[0]?.outcome.unitOfMeasure || '';
                
                // Create the chart
                this.chartManager.createTimeSeriesChart('comparisonChart', chartData, {
                    title: matchingOutcomes[0]?.outcome.title || 'Outcome Comparison',
                    yAxisLabel: unitOfMeasure,
                    isLowerBetter: matchingOutcomes[0]?.outcome.isLowerBetter || false
                });
            }
            
            createSimpleComparisonChart(matchingOutcomes) {
                // Group by trial and outcome
                const labels = [];
                const datasets = [];
                
                // Process each outcome
                matchingOutcomes.forEach(item => {
                    const trialId = item.trialId;
                    const outcome = item.outcome;
                    
                    if (outcome.values && outcome.values.length > 0) {
                        // Add trial ID to labels if not present
                        if (!labels.includes(trialId)) {
                            labels.push(trialId);
                        }
                        
                        // Group values by group name
                        const groupedValues = {};
                        outcome.values.forEach(value => {
                            if (!groupedValues[value.group]) {
                                groupedValues[value.group] = [];
                            }
                            groupedValues[value.group].push({
                                trialId: trialId,
                                value: value.value,
                                spread: value.spread
                            });
                        });
                        
                        // Create datasets for each group
                        Object.entries(groupedValues).forEach(([group, values]) => {
                            // Check if dataset exists
                            let dataset = datasets.find(ds => ds.label === group);
                            if (!dataset) {
                                // Create new dataset
                                dataset = {
                                    label: group,
                                    data: labels.map(label => {
                                        const match = values.find(v => v.trialId === label);
                                        return match ? match.value : null;
                                    }),
                                    error: labels.map(label => {
                                        const match = values.find(v => v.trialId === label);
                                        return match && match.spread ? match.spread : null;
                                    }),
                                    backgroundColor: this.chartManager.getColor(datasets.length),
                                    borderColor: this.chartManager.getColor(datasets.length, true),
                                    borderWidth: 1
                                };
                                datasets.push(dataset);
                            } else {
                                // Update existing dataset
                                labels.forEach((label, index) => {
                                    const match = values.find(v => v.trialId === label);
                                    if (match) {
                                        dataset.data[index] = match.value;
                                        dataset.error[index] = match.spread || null;
                                    }
                                });
                            }
                        });
                    }
                });
                
                // Create chart data
                const chartData = {
                    labels: labels,
                    datasets: datasets
                };
                
                // Get unit of measure from first outcome
                const unitOfMeasure = matchingOutcomes[0]?.outcome.unitOfMeasure || '';
                
                // Create the chart
                this.chartManager.createGroupedBarChart('comparisonChart', chartData, {
                    title: matchingOutcomes[0]?.outcome.title || 'Outcome Comparison',
                    yAxisLabel: unitOfMeasure,
                    isLowerBetter: matchingOutcomes[0]?.outcome.isLowerBetter || false
                });
            }
            
            addComparisonNotes(matchingOutcomes) {
                const notesContainer = document.getElementById('comparisonNotes');
                notesContainer.innerHTML = '';
                
                // Add note about interpretation
                const interpretationNote = document.createElement('li');
                const isLowerBetter = matchingOutcomes[0]?.outcome.isLowerBetter || false;
                interpretationNote.textContent = `For this outcome, ${isLowerBetter ? 'lower' : 'higher'} values indicate better results.`;
                notesContainer.appendChild(interpretationNote);
                
                // Add note about units
                const unitOfMeasure = matchingOutcomes[0]?.outcome.unitOfMeasure || '';
                if (unitOfMeasure) {
                    const unitNote = document.createElement('li');
                    unitNote.textContent = `Values are measured in ${unitOfMeasure}.`;
                    notesContainer.appendChild(unitNote);
                }
                
                // Add note about error bars if present
                const hasErrorBars = matchingOutcomes.some(item => 
                    item.outcome.values.some(v => v.spread !== undefined) ||
                    (item.outcome.valuesByTime && Object.values(item.outcome.valuesByTime)
                        .some(timeData => timeData.some(m => m.spread !== undefined)))
                );
                
                if (hasErrorBars) {
                    const errorNote = document.createElement('li');
                    errorNote.textContent = 'Error bars represent standard deviation or standard error as reported in the trial.';
                    notesContainer.appendChild(errorNote);
                }
                
                // Add note about different outcomes
                if (matchingOutcomes.length > 1) {
                    const paramTypes = new Set(matchingOutcomes.map(item => item.outcome.paramType));
                    if (paramTypes.size > 1) {
                        const paramNote = document.createElement('li');
                        paramNote.textContent = 'Note: These outcomes may have been measured differently across trials (e.g., mean vs. median values).';
                        notesContainer.appendChild(paramNote);
                    }
                }
            }
            
            setupDetailedSection() {
                // Create trial selector
                const detailedSelector = document.getElementById('detailedTrialSelector');
                detailedSelector.innerHTML = '';
                
                // Add default option
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = '-- Select a trial --';
                detailedSelector.appendChild(defaultOption);
                
                // Add options for each trial
                this.trialsData.forEach(trial => {
                    const option = document.createElement('option');
                    option.value = trial.id;
                    option.textContent = `${trial.id}: ${trial.title.substring(0, 60)}${trial.title.length > 60 ? '...' : ''}`;
                    detailedSelector.appendChild(option);
                });
            }
            
            showTrialDetails(trialId) {
                if (!trialId) {
                    document.getElementById('trialDetailsContainer').classList.add('hidden');
                    return;
                }
                
                const trial = this.trialsData.find(t => t.id === trialId);
                if (!trial) {
                    this.uiManager.showAlert(`Trial ${trialId} not found`, 'error');
                    return;
                }
                
                // Fill trial info section
                const infoContainer = document.getElementById('trialInfo');
                infoContainer.innerHTML = `
                    <table class="min-w-full text-sm">
                        <tbody>
                            <tr>
                                <td class="font-medium py-1 pr-4">Trial ID:</td>
                                <td>${trial.id}</td>
                            </tr>
                            <tr>
                                <td class="font-medium py-1 pr-4">Title:</td>
                                <td>${trial.title}</td>
                            </tr>
                            <tr>
                                <td class="font-medium py-1 pr-4">Status:</td>
                                <td><span class="px-2 py-1 rounded-full text-xs font-semibold ${this.getStatusClass(trial.status)}">${trial.status}</span></td>
                            </tr>
                            <tr>
                                <td class="font-medium py-1 pr-4">Phase:</td>
                                <td>${trial.phase}</td>
                            </tr>
                            <tr>
                                <td class="font-medium py-1 pr-4">Enrollment:</td>
                                <td>${trial.enrollment} participants</td>
                            </tr>
                            ${trial.completionRate ? `
                            <tr>
                                <td class="font-medium py-1 pr-4">Completion Rate:</td>
                                <td>${trial.completionRate.toFixed(1)}%</td>
                            </tr>` : ''}
                        </tbody>
                    </table>
                `;
                
                // Fill study design section
                const designContainer = document.getElementById('studyDesign');
                designContainer.innerHTML = `
                    <table class="min-w-full text-sm">
                        <tbody>
                            <tr>
                                <td class="font-medium py-1 pr-4">Study Type:</td>
                                <td>${trial.studyType || 'Not specified'}</td>
                            </tr>
                            <tr>
                                <td class="font-medium py-1 pr-4">Allocation:</td>
                                <td>${trial.allocation || 'Not specified'}</td>
                            </tr>
                            <tr>
                                <td class="font-medium py-1 pr-4">Intervention Model:</td>
                                <td>${trial.interventionModel || 'Not specified'}</td>
                            </tr>
                            <tr>
                                <td class="font-medium py-1 pr-4">Masking:</td>
                                <td>${trial.masking || 'Not specified'}</td>
                            </tr>
                            <tr>
                                <td class="font-medium py-1 pr-4">Primary Purpose:</td>
                                <td>${trial.primaryPurpose || 'Not specified'}</td>
                            </tr>
                        </tbody>
                    </table>
                `;
                
                // Create outcome accordions
                this.createOutcomeAccordions(trial);
                
                // Show the details container
                document.getElementById('trialDetailsContainer').classList.remove('hidden');
            }
            
            getStatusClass(status) {
                if (!status) return 'bg-gray-200 text-gray-800';
                
                status = status.toUpperCase();
                if (status === 'COMPLETED') return 'bg-green-100 text-green-800';
                if (status === 'RECRUITING') return 'bg-blue-100 text-blue-800';
                if (status === 'ACTIVE, NOT RECRUITING') return 'bg-indigo-100 text-indigo-800';
                if (status === 'TERMINATED') return 'bg-red-100 text-red-800';
                if (status === 'WITHDRAWN') return 'bg-gray-100 text-gray-800';
                if (status === 'SUSPENDED') return 'bg-yellow-100 text-yellow-800';
                
                return 'bg-gray-200 text-gray-800';
            }
            
            createOutcomeAccordions(trial) {
                const accordionContainer = document.getElementById('outcomeAccordion');
                accordionContainer.innerHTML = '';
                
                // Group outcomes by type
                const primaryOutcomes = trial.getOutcomesByType('PRIMARY');
                const secondaryOutcomes = trial.getOutcomesByType('SECONDARY');
                
                // Add label for primary outcomes if any
                if (primaryOutcomes.length > 0) {
                    const primaryLabel = document.createElement('h4');
                    primaryLabel.className = 'font-medium text-gray-700 mb-2';
                    primaryLabel.textContent = 'Primary Outcomes';
                    accordionContainer.appendChild(primaryLabel);
                    
                    // Add primary outcome accordions
                    primaryOutcomes.forEach(outcome => {
                        accordionContainer.appendChild(this.createOutcomeAccordion(trial.id, outcome));
                    });
                }
                
                // Add label for secondary outcomes if any
                if (secondaryOutcomes.length > 0) {
                    const secondaryLabel = document.createElement('h4');
                    secondaryLabel.className = 'font-medium text-gray-700 mt-4 mb-2';
                    secondaryLabel.textContent = 'Secondary Outcomes';
                    accordionContainer.appendChild(secondaryLabel);
                    
                    // Add secondary outcome accordions
                    secondaryOutcomes.forEach(outcome => {
                        accordionContainer.appendChild(this.createOutcomeAccordion(trial.id, outcome));
                    });
                }
                
                // If no outcomes, show message
                if (primaryOutcomes.length === 0 && secondaryOutcomes.length === 0) {
                    const noOutcomesMsg = document.createElement('p');
                    noOutcomesMsg.className = 'text-gray-500 italic';
                    noOutcomesMsg.textContent = 'No outcome data available for this trial.';
                    accordionContainer.appendChild(noOutcomesMsg);
                }
            }
            
            createOutcomeAccordion(trialId, outcome) {
                const accordionItem = document.createElement('div');
                accordionItem.className = 'border border-gray-200 rounded-md overflow-hidden mb-2';
                
                // Create accordion header
                const header = document.createElement('button');
                header.className = 'w-full text-left px-4 py-3 flex justify-between items-center bg-gray-50 hover:bg-gray-100 focus:outline-none';
                header.setAttribute('aria-expanded', 'false');
                header.setAttribute('aria-controls', `outcome-content-${trialId}-${outcome.id}`);
                
                const headerText = document.createElement('span');
                headerText.className = 'font-medium text-gray-700';
                headerText.textContent = outcome.title;
                
                const icon = document.createElement('svg');
                icon.className = 'h-5 w-5 text-gray-500 transform transition-transform duration-200';
                icon.setAttribute('fill', 'none');
                icon.setAttribute('viewBox', '0 0 24 24');
                icon.setAttribute('stroke', 'currentColor');
                icon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>';
                
                header.appendChild(headerText);
                header.appendChild(icon);
                
                // Create accordion content
                const content = document.createElement('div');
                content.id = `outcome-content-${trialId}-${outcome.id}`;
                content.className = 'hidden px-4 py-3 bg-white';
                
                // Description
                if (outcome.description) {
                    const description = document.createElement('p');
                    description.className = 'text-sm text-gray-600 mb-3';
                    description.textContent = outcome.description;
                    content.appendChild(description);
                }
                
                // Time frame
                if (outcome.timeFrame) {
                    const timeFrame = document.createElement('p');
                    timeFrame.className = 'text-xs text-gray-500 mb-3';
                    timeFrame.innerHTML = `<strong>Time Frame:</strong> ${outcome.timeFrame}`;
                    content.appendChild(timeFrame);
                }
                
                // Add details about the measure
                const detailsTable = document.createElement('table');
                detailsTable.className = 'w-full text-sm mb-4';
                detailsTable.innerHTML = `
                    <tbody>
                        <tr>
                            <td class="font-medium py-1 pr-4">Parameter Type:</td>
                            <td>${outcome.paramType || 'Not specified'}</td>
                        </tr>
                        <tr>
                            <td class="font-medium py-1 pr-4">Unit of Measure:</td>
                            <td>${outcome.unitOfMeasure || 'Not specified'}</td>
                        </tr>
                        <tr>
                            <td class="font-medium py-1 pr-4">Interpretation:</td>
                            <td>${outcome.isLowerBetter ? 'Lower values are better' : 'Higher values are better'}</td>
                        </tr>
                    </tbody>
                `;
                content.appendChild(detailsTable);
                
                // Create chart container if there's data
                if (outcome.hasData()) {
                    const chartContainer = document.createElement('div');
                    chartContainer.className = 'mini-chart-container mt-3 mb-2 w-full relative';
                    
                    const chartCanvas = document.createElement('canvas');
                    chartCanvas.id = `${trialId}-${outcome.id}`;
                    chartContainer.appendChild(chartCanvas);
                    
                    content.appendChild(chartContainer);
                } else {
                    const noDataMsg = document.createElement('p');
                    noDataMsg.className = 'text-gray-500 italic';
                    noDataMsg.textContent = 'No measurement data available for this outcome.';
                    content.appendChild(noDataMsg);
                }
                
                // Toggle accordion
                header.addEventListener('click', () => {
                    const expanded = header.getAttribute('aria-expanded') === 'true';
                    header.setAttribute('aria-expanded', !expanded);
                    
                    if (expanded) {
                        content.classList.add('hidden');
                        icon.classList.remove('rotate-180');
                    } else {
                        content.classList.remove('hidden');
                        icon.classList.add('rotate-180');
                        
                        // Create chart when expanded
                        if (outcome.hasData() && !content.dataset.initialized) {
                            if (outcome.valuesByTime && Object.keys(outcome.valuesByTime).length > 0) {
                                this.chartManager.createTimeSeriesDetailChart(
                                    `${trialId}-${outcome.id}`, 
                                    outcome, 
                                    { height: 250 }
                                );
                            } else {
                                this.chartManager.createBarDetailChart(
                                    `${trialId}-${outcome.id}`, 
                                    outcome, 
                                    { height: 250 }
                                );
                            }
                            content.dataset.initialized = 'true';
                        }
                    }
                });
                
                // Assemble accordion
                accordionItem.appendChild(header);
                accordionItem.appendChild(content);
                
                return accordionItem;
            }
        }
    </script>

    <script type="module">
        /**
         * TrialData.js - Module for processing clinical trial data
         */
        export class TrialData {
            constructor(jsonData, fileName) {
                this.fileName = fileName;
                this.rawData = jsonData;
                
                // Extract trial metadata
                this.id = this.extractId(jsonData);
                this.title = this.extractTitle(jsonData);
                this.status = this.extractStatus(jsonData);
                this.phase = this.extractPhase(jsonData);
                this.enrollment = this.extractEnrollment(jsonData);
                this.targetEnrollment = this.extractTargetEnrollment(jsonData);
                this.completionRate = this.extractCompletionRate(jsonData);
                
                // Extract study design
                this.studyType = this.extractStudyType(jsonData);
                this.allocation = this.extractAllocation(jsonData);
                this.interventionModel = this.extractInterventionModel(jsonData);
                this.masking = this.extractMasking(jsonData);
                this.primaryPurpose = this.extractPrimaryPurpose(jsonData);
                
                // Extract outcome data
                this.outcomes = this.extractOutcomes(jsonData);
            }
            
            extractId(jsonData) {
                return jsonData.protocolSection?.identificationModule?.nctId || 
                       `Trial_${this.fileName.replace(/\.[^/.]+$/, "")}`;
            }
            
            extractTitle(jsonData) {
                return jsonData.protocolSection?.identificationModule?.briefTitle || 
                       jsonData.protocolSection?.identificationModule?.officialTitle || 
                       'Untitled Trial';
            }
            
            extractStatus(jsonData) {
                return jsonData.protocolSection?.statusModule?.overallStatus || 'Unknown';
            }
            
            extractPhase(jsonData) {
                const phases = jsonData.protocolSection?.designModule?.phases;
                if (Array.isArray(phases) && phases.length > 0) {
                    return phases.join(', ');
                }
                return 'Not specified';
            }
            
            extractEnrollment(jsonData) {
                return jsonData.protocolSection?.designModule?.enrollmentInfo?.count || 0;
            }
            
            extractTargetEnrollment(jsonData) {
                // For trials that haven't completed enrollment, target might differ from actual
                if (this.status.toUpperCase() === 'RECRUITING' || 
                    this.status.toUpperCase() === 'NOT YET RECRUITING') {
                    return jsonData.protocolSection?.designModule?.enrollmentInfo?.count || 0;
                }
                return 0;
            }
            
            extractCompletionRate(jsonData) {
                // Try to extract from participant flow
                if (jsonData.resultsSection?.participantFlowModule?.periods) {
                    const periods = jsonData.resultsSection.participantFlowModule.periods;
                    const overallPeriod = periods.find(p => p.title.includes('Overall') || p.title.includes('overall'));
                    
                    if (overallPeriod?.milestones) {
                        const startedMilestone = overallPeriod.milestones.find(m => m.type === 'STARTED');
                        const completedMilestone = overallPeriod.milestones.find(m => m.type === 'COMPLETED');
                        
                        if (startedMilestone?.achievements && completedMilestone?.achievements) {
                            // Sum participants across all groups
                            const started = startedMilestone.achievements.reduce(
                                (sum, a) => sum + parseInt(a.numSubjects || '0'), 0);
                            const completed = completedMilestone.achievements.reduce(
                                (sum, a) => sum + parseInt(a.numSubjects || '0'), 0);
                            
                            if (started > 0) {
                                return (completed / started) * 100;
                            }
                        }
                    }
                }
                
                return null;
            }
            
            extractStudyType(jsonData) {
                return jsonData.protocolSection?.designModule?.studyType || 'Not specified';
            }
            
            extractAllocation(jsonData) {
                return jsonData.protocolSection?.designModule?.designInfo?.allocation || 'Not specified';
            }
            
            extractInterventionModel(jsonData) {
                return jsonData.protocolSection?.designModule?.designInfo?.interventionModel || 'Not specified';
            }
            
            extractMasking(jsonData) {
                const maskingInfo = jsonData.protocolSection?.designModule?.designInfo?.maskingInfo;
                if (maskingInfo) {
                    const whoMasked = maskingInfo.whoMasked ? ` (${maskingInfo.whoMasked.join(', ')})` : '';
                    return `${maskingInfo.masking}${whoMasked}`;
                }
                return 'Not specified';
            }
            
            extractPrimaryPurpose(jsonData) {
                return jsonData.protocolSection?.designModule?.designInfo?.primaryPurpose || 'Not specified';
            }
            
            extractOutcomes(jsonData) {
                if (!jsonData.resultsSection || !jsonData.resultsSection.outcomeMeasuresModule) {
                    return [];
                }
                
                const outcomeMeasures = jsonData.resultsSection.outcomeMeasuresModule.outcomeMeasures || [];
                return outcomeMeasures.map((outcome, index) => {
                    return new OutcomeData(outcome, `outcome-${index}`);
                });
            }
            
            isValid() {
                // A trial is valid if it has at least one outcome with data
                return this.outcomes.some(outcome => outcome.hasData());
            }
            
            getOutcomesByType(type) {
                return this.outcomes.filter(outcome => outcome.type === type);
            }
            
            getCompletionRate() {
                return this.completionRate || 0;
            }
            
            getSuccessRate() {
                // Calculate overall success rate based on primary outcomes
                const primaryOutcomes = this.getOutcomesByType('PRIMARY');
                if (primaryOutcomes.length === 0) return null;
                
                let successSum = 0;
                let validOutcomes = 0;
                
                primaryOutcomes.forEach(outcome => {
                    if (outcome.hasData()) {
                        // Calculate average success across groups
                        const endpointValues = outcome.getEndpointValues();
                        if (endpointValues.length > 0) {
                            // For each group, calculate improvement from baseline
                            const improvements = endpointValues.map(ev => {
                                const baselineValue = outcome.getBaselineValue(ev.group);
                                if (baselineValue !== null) {
                                    // Calculate percent improvement
                                    const change = ev.value - baselineValue;
                                    const percentChange = (baselineValue !== 0) ? 
                                        (change / Math.abs(baselineValue)) * 100 : 0;
                                    
                                    // Invert if lower is better
                                    return outcome.isLowerBetter ? -percentChange : percentChange;
                                }
                                return null;
                            }).filter(v => v !== null);
                            
                            if (improvements.length > 0) {
                                // Average improvement across groups
                                successSum += improvements.reduce((a, b) => a + b, 0) / improvements.length;
                                validOutcomes++;
                            }
                        }
                    }
                });
                
                return validOutcomes > 0 ? successSum / validOutcomes : null;
            }
        }
        
        class OutcomeData {
            constructor(outcomeData, id) {
                this.id = id;
                this.type = outcomeData.type || 'OTHER';
                this.title = outcomeData.title || 'Untitled Outcome';
                this.description = outcomeData.description || '';
                this.timeFrame = outcomeData.timeFrame || '';
                this.paramType = outcomeData.paramType || '';
                this.unitOfMeasure = outcomeData.unitOfMeasure || '';
                this.reportingStatus = outcomeData.reportingStatus || '';
                
                // Determine if lower is better based on outcome name
                this.isLowerBetter = this.determineIfLowerIsBetter(this.title);
                
                // Extract groups
                this.groups = outcomeData.groups?.map(g => ({
                    id: g.id,
                    title: g.title,
                    description: g.description || ''
                })) || [];
                
                // Process outcome measurements
                this.processOutcomeMeasurements(outcomeData);
            }
            
            determineIfLowerIsBetter(title) {
                if (!title) return false;
                
                const lowerIsBetterKeywords = [
                    'pain', 'symptom', 'fatigue', 'depression', 'anxiety', 'madrs', 'hama', 'hamd', 
                    'adverse', 'side effect', 'violence', 'victimization', 'risk', 'drinking'
                ];
                
                const outcomeLower = title.toLowerCase();
                return lowerIsBetterKeywords.some(keyword => outcomeLower.includes(keyword));
            }
            
            processOutcomeMeasurements(outcomeData) {
                this.values = [];              // For single time-point measurements
                this.valuesByTime = {};        // For time-series measurements
                this.analyses = [];            // Statistical analyses
                
                // Check if the outcome has any classes (data)
                if (!outcomeData.classes || outcomeData.classes.length === 0) {
                    return;
                }
                
                // Process analyses if present
                if (outcomeData.analyses && outcomeData.analyses.length > 0) {
                    this.analyses = outcomeData.analyses.map(analysis => ({
                        groups: analysis.groupIds || [],
                        pValue: analysis.pValue || null,
                        method: analysis.statisticalMethod || '',
                        comment: analysis.statisticalComment || '',
                        paramType: analysis.paramType || '',
                        paramValue: analysis.paramValue || null,
                        ciPctValue: analysis.ciPctValue || null,
                        ciLowerLimit: analysis.ciLowerLimit || null,
                        ciUpperLimit: analysis.ciUpperLimit || null
                    }));
                }
                
                // Check for time-based structure (classes with titles like "Baseline", "Week 6", etc.)
                const hasTimeBasedClasses = outcomeData.classes.some(cls => 
                    cls.title && (
                        cls.title.toLowerCase().includes('baseline') || 
                        cls.title.toLowerCase().includes('month') ||
                        cls.title.toLowerCase().includes('week') ||
                        cls.title.toLowerCase().includes('day') ||
                        cls.title.toLowerCase().includes('hour')
                    )
                );
                
                if (hasTimeBasedClasses) {
                    // Process as time-series data
                    outcomeData.classes.forEach(cls => {
                        if (!cls.title || !cls.categories) return;
                        
                        const timePoint = cls.title;
                        this.valuesByTime[timePoint] = [];
                        
                        cls.categories.forEach(cat => {
                            if (!cat.measurements) return;
                            
                            cat.measurements.forEach(m => {
                                if (m.value === undefined || m.value === null || m.value === "") return;
                                
                                // Find group name
                                const group = this.groups.find(g => g.id === m.groupId)?.title || `Group ${m.groupId}`;
                                
                                // Add measurement
                                this.valuesByTime[timePoint].push({
                                    group: group,
                                    value: parseFloat(m.value),
                                    spread: m.spread !== undefined ? parseFloat(m.spread) : undefined
                                });
                            });
                        });
                    });
                } else {
                    // Process as single time-point data
                    outcomeData.classes.forEach(cls => {
                        if (!cls.categories) return;
                        
                        cls.categories.forEach(cat => {
                            if (!cat.measurements) return;
                            
                            cat.measurements.forEach(m => {
                                if (m.value === undefined || m.value === null || m.value === "") return;
                                
                                // Find group name
                                const group = this.groups.find(g => g.id === m.groupId)?.title || `Group ${m.groupId}`;
                                
                                // Add measurement
                                this.values.push({
                                    group: group,
                                    value: parseFloat(m.value),
                                    spread: m.spread !== undefined ? parseFloat(m.spread) : undefined
                                });
                            });
                        });
                    });
                }
            }
            
            hasData() {
                return (this.values && this.values.length > 0) || 
                       (this.valuesByTime && Object.keys(this.valuesByTime).length > 0);
            }
            
            getEndpointValues() {
                // If time-series data, use the last time point
                if (this.valuesByTime && Object.keys(this.valuesByTime).length > 0) {
                    const timePoints = Object.keys(this.valuesByTime);
                    
                    // Sort time points (try to handle numeric and text-based time points)
                    timePoints.sort((a, b) => {
                        // Try to extract numeric values for comparison
                        const aNum = parseFloat(a.match(/(\d+)/) ? a.match(/(\d+)/)[0] : a);
                        const bNum = parseFloat(b.match(/(\d+)/) ? b.match(/(\d+)/)[0] : b);
                        
                        if (!isNaN(aNum) && !isNaN(bNum)) return aNum - bNum;
                        return a.localeCompare(b);
                    });
                    
                    // Return values from the last time point
                    return this.valuesByTime[timePoints[timePoints.length - 1]] || [];
                }
                
                // Otherwise, use single values
                return this.values || [];
            }
            
            getBaselineValue(group) {
                if (!this.valuesByTime) return null;
                
                // Find baseline or similar time point
                const baselineKey = Object.keys(this.valuesByTime).find(key => 
                    key.toLowerCase().includes('baseline') || 
                    key.toLowerCase().includes('pre') || 
                    key.toLowerCase().includes('start')
                );
                
                if (!baselineKey) return null;
                
                // Find value for the specified group
                const measurement = this.valuesByTime[baselineKey].find(m => m.group === group);
                return measurement ? measurement.value : null;
            }
        }
    </script>

    <script type="module">
        /**
         * ChartManager.js - Module for creating and managing visualization charts
         */
        export class ChartManager {
            constructor() {
                this.charts = {};
                this.fullscreenChart = null;
                this.registerPlugins();
                this.colors = [
                    'rgba(59, 130, 246, 0.7)',  // Blue
                    'rgba(234, 88, 12, 0.7)',   // Orange
                    'rgba(16, 185, 129, 0.7)',  // Green
                    'rgba(168, 85, 247, 0.7)',  // Purple
                    'rgba(239, 68, 68, 0.7)',   // Red
                    'rgba(245, 158, 11, 0.7)',  // Amber
                    'rgba(14, 165, 233, 0.7)',  // Sky
                    'rgba(249, 115, 22, 0.7)',  // Orange
                    'rgba(236, 72, 153, 0.7)',  // Pink
                    'rgba(79, 70, 229, 0.7)'    // Indigo
                ];
            }
            
            registerPlugins() {
                // Register any Chart.js plugins if needed
                try {
                    Chart.register(ChartDataLabels);
                } catch (e) {
                    console.warn('ChartDataLabels plugin not available');
                }
            }
            
            getColor(index, solid = false) {
                const colorIndex = index % this.colors.length;
                return solid ? this.colors[colorIndex].replace('0.7', '1') : this.colors[colorIndex];
            }
            
            destroyAllCharts() {
                for (const chartId in this.charts) {
                    if (this.charts[chartId]) {
                        this.charts[chartId].destroy();
                        delete this.charts[chartId];
                    }
                }
                
                if (this.fullscreenChart) {
                    this.fullscreenChart.destroy();
                    this.fullscreenChart = null;
                }
            }
            
            createSuccessRateChart(canvasId, data) {
                const ctx = document.getElementById(canvasId)?.getContext('2d');
                if (!ctx) return;
                
                if (this.charts[canvasId]) {
                    this.charts[canvasId].destroy();
                }
                
                this.charts[canvasId] = new Chart(ctx, {
                    type: 'bar',
                    data: data,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        if (context.raw === null) return 'No data available';
                                        return `${context.dataset.label}: ${context.raw.toFixed(1)}%`;
                                    }
                                }
                            },
                            annotation: {
                                annotations: {
                                    zeroLine: {
                                        type: 'line',
                                        yMin: 0,
                                        yMax: 0,
                                        borderColor: 'rgba(100, 100, 100, 0.5)',
                                        borderWidth: 2,
                                        borderDash: [6, 6]
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                title: {
                                    display: true,
                                    text: 'Success Rate (%)',
                                    font: {
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    callback: function(value) {
                                        return value + '%';
                                    }
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Trial ID',
                                    font: {
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            }
                        }
                    }
                });
            }
            
            createCompletionRateChart(canvasId, data) {
                const ctx = document.getElementById(canvasId)?.getContext('2d');
                if (!ctx) return;
                
                if (this.charts[canvasId]) {
                    this.charts[canvasId].destroy();
                }
                
                this.charts[canvasId] = new Chart(ctx, {
                    type: 'bar',
                    data: data,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `${context.dataset.label}: ${context.raw.toFixed(1)}%`;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                title: {
                                    display: true,
                                    text: 'Completion Rate (%)',
                                    font: {
                                        weight: 'bold'
                                    }
                                },
                                min: 0,
                                max: 100,
                                ticks: {
                                    callback: function(value) {
                                        return value + '%';
                                    }
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Trial ID',
                                    font: {
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            }
                        }
                    }
                });
            }
            
            createEnrollmentChart(canvasId, data) {
                const ctx = document.getElementById(canvasId)?.getContext('2d');
                if (!ctx) return;
                
                if (this.charts[canvasId]) {
                    this.charts[canvasId].destroy();
                }
                
                this.charts[canvasId] = new Chart(ctx, {
                    type: 'bar',
                    data: data,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            }
                        },
                        scales: {
                            y: {
                                title: {
                                    display: true,
                                    text: 'Number of Participants',
                                    font: {
                                        weight: 'bold'
                                    }
                                },
                                beginAtZero: true
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Trial ID',
                                    font: {
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            }
                        }
                    }
                });
            }
            
            createTimeSeriesChart(canvasId, data, options = {}) {
                const ctx = document.getElementById(canvasId)?.getContext('2d');
                if (!ctx) return;
                
                if (this.charts[canvasId]) {
                    this.charts[canvasId].destroy();
                }
                
                this.charts[canvasId] = new Chart(ctx, {
                    type: 'line',
                    data: data,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            title: {
                                display: true,
                                text: options.title || 'Outcome Comparison',
                                font: {
                                    size: 16,
                                    weight: 'bold'
                                }
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false
                            },
                            annotation: {
                                annotations: {
                                    zeroLine: {
                                        type: 'line',
                                        yMin: 0,
                                        yMax: 0,
                                        borderColor: 'rgba(100, 100, 100, 0.5)',
                                        borderWidth: 2,
                                        borderDash: [6, 6],
                                        display: true
                                    }
                                }
                            }
                        },
                        interaction: {
                            mode: 'nearest',
                            axis: 'x',
                            intersect: false
                        },
                        scales: {
                            y: {
                                title: {
                                    display: true,
                                    text: options.yAxisLabel || '',
                                    font: {
                                        weight: 'bold'
                                    }
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Time Point',
                                    font: {
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            }
                        }
                    }
                });
            }
            
            createGroupedBarChart(canvasId, data, options = {}) {
                const ctx = document.getElementById(canvasId)?.getContext('2d');
                if (!ctx) return;
                
                if (this.charts[canvasId]) {
                    this.charts[canvasId].destroy();
                }
                
                // Add error bars to datasets if present
                const datasets = data.datasets.map(dataset => {
                    return {
                        ...dataset,
                        // Add error bar configuration
                        errorBars: dataset.error ? {
                            enabled: true,
                            color: dataset.borderColor,
                            lineWidth: 1,
                            tipWidth: 6
                        } : undefined
                    };
                });
                
                this.charts[canvasId] = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        ...data,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            title: {
                                display: true,
                                text: options.title || 'Outcome Comparison',
                                font: {
                                    size: 16,
                                    weight: 'bold'
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            label += context.parsed.y.toFixed(2);
                                            if (context.dataset.error && context.dataset.error[context.dataIndex]) {
                                                label += ` ± ${context.dataset.error[context.dataIndex].toFixed(2)}`;
                                            }
                                        }
                                        return label;
                                    }
                                }
                            },
                            annotation: {
                                annotations: {
                                    zeroLine: {
                                        type: 'line',
                                        yMin: 0,
                                        yMax: 0,
                                        borderColor: 'rgba(100, 100, 100, 0.5)',
                                        borderWidth: 2,
                                        borderDash: [6, 6],
                                        display: true
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                title: {
                                    display: true,
                                    text: options.yAxisLabel || '',
                                    font: {
                                        weight: 'bold'
                                    }
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Trial',
                                    font: {
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            }
                        }
                    }
                });
                
                // Manually draw error bars if dataset has error values
                // This is necessary because Chart.js doesn't have built-in error bars
                const originalDraw = this.charts[canvasId].draw;
                this.charts[canvasId].draw = function() {
                    originalDraw.apply(this, arguments);
                    
                    const meta = this.getDatasetMeta(0);
                    const yScale = this.scales.y;
                    const ctx = this.ctx;
                    
                    data.datasets.forEach((dataset, datasetIndex) => {
                        if (!dataset.error) return;
                        
                        const meta = this.getDatasetMeta(datasetIndex);
                        
                        dataset.error.forEach((err, index) => {
                            if (err === null || err === undefined) return;
                            
                            const bar = meta.data[index];
                            if (!bar) return;
                            
                            const centerX = bar.x;
                            const value = dataset.data[index];
                            if (value === null || value === undefined) return;
                            
                            const centerY = yScale.getPixelForValue(value);
                            const tipWidth = 6;
                            
                            // Calculate error positions
                            const yPlus = yScale.getPixelForValue(value + err);
                            const yMinus = yScale.getPixelForValue(value - err);
                            
                            // Draw error bar
                            ctx.save();
                            ctx.beginPath();
                            ctx.lineWidth = 1;
                            ctx.strokeStyle = typeof dataset.borderColor === 'string' 
                                ? dataset.borderColor 
                                : dataset.borderColor[index] || 'rgba(0,0,0,0.8)';
                            
                            // Vertical line
                            ctx.moveTo(centerX, yPlus);
                            ctx.lineTo(centerX, yMinus);
                            
                            // Top horizontal line
                            ctx.moveTo(centerX - tipWidth / 2, yPlus);
                            ctx.lineTo(centerX + tipWidth / 2, yPlus);
                            
                            // Bottom horizontal line
                            ctx.moveTo(centerX - tipWidth / 2, yMinus);
                            ctx.lineTo(centerX + tipWidth / 2, yMinus);
                            
                            ctx.stroke();
                            ctx.restore();
                        });
                    });
                };
            }
            
            createTimeSeriesDetailChart(canvasId, outcome, options = {}) {
                const ctx = document.getElementById(canvasId)?.getContext('2d');
                if (!ctx) return;
                
                if (this.charts[canvasId]) {
                    this.charts[canvasId].destroy();
                }
                
                // Sort time points (try to handle numeric and text-based time points)
                const timePoints = Object.keys(outcome.valuesByTime).sort((a, b) => {
                    // Try to extract numeric values for comparison
                    const aNum = parseFloat(a.match(/(\d+)/) ? a.match(/(\d+)/)[0] : a);
                    const bNum = parseFloat(b.match(/(\d+)/) ? b.match(/(\d+)/)[0] : b);
                    
                    if (!isNaN(aNum) && !isNaN(bNum)) return aNum - bNum;
                    return a.localeCompare(b);
                });
                
                // Extract unique groups across all time points
                const groups = new Set();
                Object.values(outcome.valuesByTime).forEach(timeData => {
                    timeData.forEach(measurement => groups.add(measurement.group));
                });
                
                // Create datasets for each group
                const datasets = Array.from(groups).map((group, index) => {
                    // Gather data for this group across all time points
                    const data = timePoints.map(time => {
                        const timeData = outcome.valuesByTime[time];
                        const measurement = timeData.find(m => m.group === group);
                        return measurement ? measurement.value : null;
                    });
                    
                    // Gather error data if available
                    const errorData = timePoints.map(time => {
                        const timeData = outcome.valuesByTime[time];
                        const measurement = timeData.find(m => m.group === group);
                        return measurement && measurement.spread ? measurement.spread : null;
                    });
                    
                    // Check if we have any error values
                    const hasError = errorData.some(err => err !== null);
                    
                    return {
                        label: group,
                        data: data,
                        error: hasError ? errorData : undefined,
                        backgroundColor: this.getColor(index),
                        borderColor: this.getColor(index, true),
                        fill: false,
                        tension: 0.1,
                        borderWidth: 2
                    };
                });
                
                // Create chart data
                const chartData = {
                    labels: timePoints,
                    datasets: datasets
                };
                
                const chartConfig = {
                    type: 'line',
                    data: chartData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            label += context.parsed.y.toFixed(2);
                                            if (context.dataset.error && context.dataset.error[context.dataIndex]) {
                                                label += ` ± ${context.dataset.error[context.dataIndex].toFixed(2)}`;
                                            }
                                        }
                                        return label;
                                    }
                                }
                            },
                            annotation: {
                                annotations: {
                                    zeroLine: {
                                        type: 'line',
                                        yMin: 0,
                                        yMax: 0,
                                        borderColor: 'rgba(100, 100, 100, 0.5)',
                                        borderWidth: 2,
                                        borderDash: [6, 6],
                                        display: true
                                    }
                                }
                            }
                        },
                        interaction: {
                            mode: 'nearest',
                            axis: 'x',
                            intersect: false
                        },
                        scales: {
                            y: {
                                title: {
                                    display: true,
                                    text: outcome.unitOfMeasure || '',
                                    font: {
                                        weight: 'bold'
                                    }
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Time Point',
                                    font: {
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            }
                        }
                    }
                };
                
                // Set height if specified
                if (options.height) {
                    chartConfig.options.maintainAspectRatio = false;
                    chartConfig.options.responsive = true;
                    ctx.canvas.parentNode.style.height = `${options.height}px`;
                }
                
                this.charts[canvasId] = new Chart(ctx, chartConfig);
                
                // Manually draw error bars if dataset has error values
                const originalDraw = this.charts[canvasId].draw;
                this.charts[canvasId].draw = function() {
                    originalDraw.apply(this, arguments);
                    
                    const yScale = this.scales.y;
                    const ctx = this.ctx;
                    
                    this.data.datasets.forEach((dataset, datasetIndex) => {
                        if (!dataset.error) return;
                        
                        const meta = this.getDatasetMeta(datasetIndex);
                        
                        dataset.error.forEach((err, index) => {
                            if (err === null || err === undefined) return;
                            
                            const point = meta.data[index];
                            if (!point || !point.active) return;
                            
                            const centerX = point.x;
                            const value = dataset.data[index];
                            if (value === null || value === undefined) return;
                            
                            const centerY = yScale.getPixelForValue(value);
                            const tipWidth = 6;
                            
                            // Calculate error positions
                            const yPlus = yScale.getPixelForValue(value + err);
                            const yMinus = yScale.getPixelForValue(value - err);
                            
                            // Draw error bar
                            ctx.save();
                            ctx.beginPath();
                            ctx.lineWidth = 1;
                            ctx.strokeStyle = typeof dataset.borderColor === 'string' 
                                ? dataset.borderColor 
                                : dataset.borderColor[index] || 'rgba(0,0,0,0.8)';
                            
                            // Vertical line
                            ctx.moveTo(centerX, yPlus);
                            ctx.lineTo(centerX, yMinus);
                            
                            // Top horizontal line
                            ctx.moveTo(centerX - tipWidth / 2, yPlus);
                            ctx.lineTo(centerX + tipWidth / 2, yPlus);
                            
                            // Bottom horizontal line
                            ctx.moveTo(centerX - tipWidth / 2, yMinus);
                            ctx.lineTo(centerX + tipWidth / 2, yMinus);
                            
                            ctx.stroke();
                            ctx.restore();
                        });
                    });
                };
            }
            
            createBarDetailChart(canvasId, outcome, options = {}) {
                const ctx = document.getElementById(canvasId)?.getContext('2d');
                if (!ctx) return;
                
                if (this.charts[canvasId]) {
                    this.charts[canvasId].destroy();
                }
                
                // Extract data
                const labels = outcome.values.map(v => v.group);
                const data = outcome.values.map(v => v.value);
                const errorData = outcome.values.map(v => v.spread);
                
                // Check if we have any error values
                const hasError = errorData.some(err => err !== null && err !== undefined);
                
                // Create chart data
                const chartData = {
                    labels: labels,
                    datasets: [{
                        label: outcome.title,
                        data: data,
                        error: hasError ? errorData : undefined,
                        backgroundColor: labels.map((_, i) => this.getColor(i)),
                        borderColor: labels.map((_, i) => this.getColor(i, true)),
                        borderWidth: 1
                    }]
                };
                
                const chartConfig = {
                    type: 'bar',
                    data: chartData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: options.horizontal ? 'y' : 'x',
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            label += context.parsed.y.toFixed(2);
                                            if (context.dataset.error && context.dataset.error[context.dataIndex]) {
                                                label += ` ± ${context.dataset.error[context.dataIndex].toFixed(2)}`;
                                            }
                                        }
                                        return label;
                                    }
                                }
                            },
                            annotation: {
                                annotations: {
                                    zeroLine: {
                                        type: 'line',
                                        yMin: 0,
                                        yMax: 0,
                                        borderColor: 'rgba(100, 100, 100, 0.5)',
                                        borderWidth: 2,
                                        borderDash: [6, 6],
                                        display: true
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                title: {
                                    display: true,
                                    text: outcome.unitOfMeasure || '',
                                    font: {
                                        weight: 'bold'
                                    }
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Group',
                                    font: {
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            }
                        }
                    }
                };
                
                // Set height if specified
                if (options.height) {
                    chartConfig.options.maintainAspectRatio = false;
                    chartConfig.options.responsive = true;
                    ctx.canvas.parentNode.style.height = `${options.height}px`;
                }
                
                this.charts[canvasId] = new Chart(ctx, chartConfig);
                
                // Manually draw error bars if dataset has error values
                if (hasError) {
                    const originalDraw = this.charts[canvasId].draw;
                    this.charts[canvasId].draw = function() {
                        originalDraw.apply(this, arguments);
                        
                        const meta = this.getDatasetMeta(0);
                        const yScale = this.scales.y;
                        const ctx = this.ctx;
                        
                        chartData.datasets[0].error.forEach((err, index) => {
                            if (err === null || err === undefined) return;
                            
                            const bar = meta.data[index];
                            if (!bar) return;
                            
                            const centerX = bar.x;
                            const value = chartData.datasets[0].data[index];
                            if (value === null || value === undefined) return;
                            
                            const centerY = yScale.getPixelForValue(value);
                            const tipWidth = 6;
                            
                            // Calculate error positions
                            const yPlus = yScale.getPixelForValue(value + err);
                            const yMinus = yScale.getPixelForValue(value - err);
                            
                            // Draw error bar
                            ctx.save();
                            ctx.beginPath();
                            ctx.lineWidth = 1;
                            ctx.strokeStyle = typeof chartData.datasets[0].borderColor === 'string' 
                                ? chartData.datasets[0].borderColor 
                                : chartData.datasets[0].borderColor[index] || 'rgba(0,0,0,0.8)';
                            
                            // Vertical line
                            ctx.moveTo(centerX, yPlus);
                            ctx.lineTo(centerX, yMinus);
                            
                            // Top horizontal line
                            ctx.moveTo(centerX - tipWidth / 2, yPlus);
                            ctx.lineTo(centerX + tipWidth / 2, yPlus);
                            
                            // Bottom horizontal line
                            ctx.moveTo(centerX - tipWidth / 2, yMinus);
                            ctx.lineTo(centerX + tipWidth / 2, yMinus);
                            
                            ctx.stroke();
                            ctx.restore();
                        });
                    };
                }
            }
            
            openFullscreenChart(sourceChartId, title) {
                const sourceChart = this.charts[sourceChartId];
                if (!sourceChart) return;
                
                // Show modal
                document.getElementById('fullscreenModal').classList.remove('hidden');
                document.getElementById('fullscreenChartTitle').textContent = title;
                
                // Clone chart configuration
                const config = sourceChart.config ? { ...sourceChart.config } : { type: sourceChart.config.type, data: sourceChart.config.data, options: { ...sourceChart.config.options } };
                
                // Update options for fullscreen
                if (config.options) {
                    config.options.plugins = config.options.plugins || {};
                    config.options.plugins.legend = { 
                        display: true, 
                        position: 'top',
                        labels: {
                            font: {
                                size: 14
                            }
                        }
                    };
                    
                    if (config.options.plugins.title) {
                        config.options.plugins.title.font = {
                            size: 18,
                            weight: 'bold'
                        };
                    }
                    
                    // Larger fonts for axes
                    if (config.options.scales) {
                        for (const axis in config.options.scales) {
                            if (config.options.scales[axis].title) {
                                config.options.scales[axis].title.font = {
                                    size: 16,
                                    weight: 'bold'
                                };
                            }
                            
                            if (config.options.scales[axis].ticks) {
                                config.options.scales[axis].ticks.font = {
                                    size: 14
                                };
                            }
                        }
                    }
                }
                
                // Create new chart in fullscreen canvas
                const fullscreenCtx = document.getElementById('fullscreenChart').getContext('2d');
                if (this.fullscreenChart) {
                    this.fullscreenChart.destroy();
                }
                
                this.fullscreenChart = new Chart(fullscreenCtx, config);
                
                // Add keyboard listener for escape key
                document.addEventListener('keydown', this.handleEscKey);
            }
            
            handleEscKey(e) {
                if (e.key === 'Escape') {
                    document.getElementById('fullscreenModal').classList.add('hidden');
                    document.removeEventListener('keydown', this.handleEscKey);
                }
            }
            
            closeFullscreenChart() {
                document.getElementById('fullscreenModal').classList.add('hidden');
                document.removeEventListener('keydown', this.handleEscKey);
                
                if (this.fullscreenChart) {
                    this.fullscreenChart.destroy();
                    this.fullscreenChart = null;
                }
            }
        }
    </script>

    <script type="module">
        /**
         * UIManager.js - Module for managing UI elements and interactions
         */
        export class UIManager {
            constructor() {
                this.alertTimeout = null;
                this.progressInterval = null;
            }
            
            clearResults() {
                document.getElementById('navigationTabs').classList.add('hidden');
                document.getElementById('overviewSection').classList.add('hidden');
                document.getElementById('comparisonSection').classList.add('hidden');
                document.getElementById('detailedSection').classList.add('hidden');
                document.getElementById('noDataMessage').classList.add('hidden');
                
                document.getElementById('trialsOverview').innerHTML = '';
                document.getElementById('trialSelectors').innerHTML = '';
                document.getElementById('outcomeSelector').innerHTML = '';
                document.getElementById('detailedTrialSelector').innerHTML = '';
            }
            
            showNavigationTabs() {
                document.getElementById('navigationTabs').classList.remove('hidden');
            }
            
            switchView(view) {
                // Hide all sections
                document.getElementById('overviewSection').classList.add('hidden');
                document.getElementById('comparisonSection').classList.add('hidden');
                document.getElementById('detailedSection').classList.add('hidden');
                
                // Show selected section
                document.getElementById(`${view}Section`).classList.remove('hidden');
                
                // Update tab styling
                document.querySelectorAll('.tab-button').forEach(tab => {
                    tab.classList.remove('border-indigo-500', 'text-indigo-600');
                    tab.classList.add('border-transparent', 'text-gray-500');
                });
                
                document.getElementById(`tab${view.charAt(0).toUpperCase() + view.slice(1)}`).classList.remove('border-transparent', 'text-gray-500');
                document.getElementById(`tab${view.charAt(0).toUpperCase() + view.slice(1)}`).classList.add('border-indigo-500', 'text-indigo-600');
            }
            
            showProcessingStatus() {
                const statusElement = document.getElementById('processingStatus');
                statusElement.classList.remove('hidden');
                document.getElementById('statusText').textContent = 'Processing files...';
                document.getElementById('progressBar').style.width = '0%';
                
                // Add animation to loader
                const loader = statusElement.querySelector('.loader');
                if (loader) {
                    loader.classList.add('animate-spin');
                }
            }
            
            hideProcessingStatus() {
                document.getElementById('processingStatus').classList.add('hidden');
                
                if (this.progressInterval) {
                    clearInterval(this.progressInterval);
                    this.progressInterval = null;
                }
            }
            
            updateProgress(processed, total) {
                const percentComplete = (processed / total) * 100;
                document.getElementById('progressBar').style.width = `${percentComplete}%`;
                document.getElementById('statusText').textContent = 
                    `Processing files... ${processed} of ${total} complete`;
            }
            
            showNoDataMessage(reason) {
                document.getElementById('noDataMessage').classList.remove('hidden');
                if (reason) {
                    document.getElementById('noDataReason').textContent = reason;
                }
            }
            
            createTrialOverviewCards(trialsData) {
                const overviewContainer = document.getElementById('trialsOverview');
                overviewContainer.innerHTML = '';
                
                trialsData.forEach(trial => {
                    const card = this.createTrialCard(trial);
                    overviewContainer.appendChild(card);
                });
            }
            
            createTrialCard(trial) {
                const card = document.createElement('div');
                card.className = 'trial-card bg-white rounded-lg p-4 border border-gray-200 hover:shadow-lg transition-all duration-200';
                
               // Status badge
               const statusBadge = document.createElement('div');
                statusBadge.className = `text-xs font-semibold inline-block py-1 px-2 rounded-full ${this.getStatusClass(trial.status)} mb-2`;
                statusBadge.textContent = trial.status;
                
                // Title and ID
                const title = document.createElement('h3');
                title.className = 'text-base font-semibold mb-1 text-gray-800';
                title.textContent = trial.title.length > 80 ? trial.title.substring(0, 80) + '...' : trial.title;
                title.title = trial.title; // Full title on hover
                
                const id = document.createElement('p');
                id.className = 'text-sm text-gray-500 mb-2';
                id.textContent = `ID: ${trial.id}`;
                
                // Trial details
                const details = document.createElement('div');
                details.className = 'grid grid-cols-2 gap-x-4 gap-y-1 text-sm mb-3';
                
                const phaseLabel = document.createElement('div');
                phaseLabel.className = 'text-gray-600';
                phaseLabel.textContent = 'Phase:';
                
                const phaseValue = document.createElement('div');
                phaseValue.className = 'text-gray-800 font-medium';
                phaseValue.textContent = trial.phase;
                
                const enrollmentLabel = document.createElement('div');
                enrollmentLabel.className = 'text-gray-600';
                enrollmentLabel.textContent = 'Enrollment:';
                
                const enrollmentValue = document.createElement('div');
                enrollmentValue.className = 'text-gray-800 font-medium';
                enrollmentValue.textContent = `${trial.enrollment} participants`;
                
                const completionLabel = document.createElement('div');
                completionLabel.className = 'text-gray-600';
                completionLabel.textContent = 'Completion:';
                
                const completionValue = document.createElement('div');
                completionValue.className = 'text-gray-800 font-medium';
                completionValue.textContent = trial.completionRate ? `${trial.completionRate.toFixed(1)}%` : 'N/A';
                
                details.appendChild(phaseLabel);
                details.appendChild(phaseValue);
                details.appendChild(enrollmentLabel);
                details.appendChild(enrollmentValue);
                details.appendChild(completionLabel);
                details.appendChild(completionValue);
                
                // Outcomes summary
                const primaryOutcomes = trial.getOutcomesByType('PRIMARY');
                const secondaryOutcomes = trial.getOutcomesByType('SECONDARY');
                
                const outcomesSummary = document.createElement('div');
                outcomesSummary.className = 'text-sm mb-2';
                outcomesSummary.innerHTML = `
                    <span class="text-gray-600">Outcomes:</span>
                    <span class="text-gray-800 font-medium">${primaryOutcomes.length} primary, ${secondaryOutcomes.length} secondary</span>
                `;
                
                // View buttons
                const buttonsContainer = document.createElement('div');
                buttonsContainer.className = 'flex justify-end space-x-2 mt-2';
                
                const compareButton = document.createElement('button');
                compareButton.className = 'px-3 py-1 text-xs font-medium text-white bg-indigo-600 rounded hover:bg-indigo-700 transition-colors';
                compareButton.textContent = 'Compare';
                compareButton.addEventListener('click', () => {
                    // Switch to comparison tab and select this trial
                    document.getElementById('tabComparison').click();
                    const checkbox = document.querySelector(`input[data-trial-id="${trial.id}"]`);
                    if (checkbox) {
                        checkbox.checked = true;
                        checkbox.dispatchEvent(new Event('change'));
                    }
                });
                
                const detailsButton = document.createElement('button');
                detailsButton.className = 'px-3 py-1 text-xs font-medium text-indigo-600 bg-indigo-100 rounded hover:bg-indigo-200 transition-colors';
                detailsButton.textContent = 'Details';
                detailsButton.addEventListener('click', () => {
                    // Switch to detailed tab and select this trial
                    document.getElementById('tabDetailed').click();
                    const selector = document.getElementById('detailedTrialSelector');
                    selector.value = trial.id;
                    selector.dispatchEvent(new Event('change'));
                });
                
                buttonsContainer.appendChild(compareButton);
                buttonsContainer.appendChild(detailsButton);
                
                // Assemble card
                card.appendChild(statusBadge);
                card.appendChild(title);
                card.appendChild(id);
                card.appendChild(details);
                card.appendChild(outcomesSummary);
                card.appendChild(buttonsContainer);
                
                return card;
            }
            
            getStatusClass(status) {
                if (!status) return 'bg-gray-200 text-gray-800';
                
                status = status.toUpperCase();
                if (status === 'COMPLETED') return 'bg-green-100 text-green-800';
                if (status === 'RECRUITING') return 'bg-blue-100 text-blue-800';
                if (status === 'ACTIVE, NOT RECRUITING') return 'bg-indigo-100 text-indigo-800';
                if (status === 'TERMINATED') return 'bg-red-100 text-red-800';
                if (status === 'WITHDRAWN') return 'bg-gray-100 text-gray-800';
                if (status === 'SUSPENDED') return 'bg-yellow-100 text-yellow-800';
                
                return 'bg-gray-200 text-gray-800';
            }
            
            createTrialSelectors(trialsData, onChangeCallback) {
                const selectorContainer = document.getElementById('trialSelectors');
                selectorContainer.innerHTML = '';
                
                trialsData.forEach(trial => {
                    const label = document.createElement('label');
                    label.className = 'flex items-center space-x-3';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded';
                    checkbox.dataset.trialId = trial.id;
                    
                    checkbox.addEventListener('change', (e) => {
                        if (onChangeCallback) {
                            onChangeCallback(trial.id, e.target.checked);
                        }
                    });
                    
                    const span = document.createElement('span');
                    span.className = 'text-sm text-gray-700';
                    
                    // Add status badge
                    const statusBadge = document.createElement('span');
                    statusBadge.className = `inline-block px-2 py-0.5 mr-1 rounded-full text-xs ${this.getStatusClass(trial.status)}`;
                    statusBadge.textContent = trial.status;
                    
                    span.appendChild(statusBadge);
                    span.appendChild(document.createTextNode(` ${trial.id}: ${trial.title.substring(0, 40)}${trial.title.length > 40 ? '...' : ''}`));
                    
                    label.appendChild(checkbox);
                    label.appendChild(span);
                    
                    selectorContainer.appendChild(label);
                });
            }
            
            showAlert(message, type = 'info') {
                // Clear any existing alert
                if (this.alertTimeout) {
                    clearTimeout(this.alertTimeout);
                    this.alertTimeout = null;
                }
                
                const alertToast = document.getElementById('alertToast');
                const alertTitle = document.getElementById('alertTitle');
                const alertMessage = document.getElementById('alertMessage');
                const alertIcon = document.getElementById('alertIcon');
                const alertProgress = document.getElementById('alertProgress');
                
                // Set alert content and style based on type
                switch (type) {
                    case 'error':
                        alertTitle.textContent = 'Error';
                        alertIcon.innerHTML = `
                            <svg class="h-5 w-5 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                            </svg>
                        `;
                        alertProgress.className = 'bg-red-600 h-0.5';
                        break;
                    case 'success':
                        alertTitle.textContent = 'Success';
                        alertIcon.innerHTML = `
                            <svg class="h-5 w-5 text-green-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                            </svg>
                        `;
                        alertProgress.className = 'bg-green-600 h-0.5';
                        break;
                    case 'warning':
                        alertTitle.textContent = 'Warning';
                        alertIcon.innerHTML = `
                            <svg class="h-5 w-5 text-yellow-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                            </svg>
                        `;
                        alertProgress.className = 'bg-yellow-600 h-0.5';
                        break;
                    case 'info':
                    default:
                        alertTitle.textContent = 'Information';
                        alertIcon.innerHTML = `
                            <svg class="h-5 w-5 text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                        `;
                        alertProgress.className = 'bg-blue-600 h-0.5';
                        break;
                }
                
                alertMessage.textContent = message;
                
                // Show the alert
                alertToast.classList.remove('hidden');
                
                // Animate progress bar
                alertProgress.style.width = '100%';
                alertProgress.style.transition = 'width 5s linear';
                
                // Set timeout to hide alert after 5 seconds
                this.alertTimeout = setTimeout(() => {
                    this.hideAlert();
                }, 5000);
                
                // Start animation to reduce width
                setTimeout(() => {
                    alertProgress.style.width = '0%';
                }, 100);
            }
            
            hideAlert() {
                document.getElementById('alertToast').classList.add('hidden');
                
                if (this.alertTimeout) {
                    clearTimeout(this.alertTimeout);
                    this.alertTimeout = null;
                }
            }
        }
    </script>
    <script type="module">
        // Define modules globally so they can be accessed by the HTML file
window.TrialData = class TrialData {
    constructor(jsonData, fileName) {
        this.fileName = fileName;
        this.rawData = jsonData;
        
        // Extract trial metadata
        this.id = this.extractId(jsonData);
        this.title = this.extractTitle(jsonData);
        this.status = this.extractStatus(jsonData);
        this.phase = this.extractPhase(jsonData);
        this.enrollment = this.extractEnrollment(jsonData);
        this.targetEnrollment = this.extractTargetEnrollment(jsonData);
        this.completionRate = this.extractCompletionRate(jsonData);
        
        // Extract study design
        this.studyType = this.extractStudyType(jsonData);
        this.allocation = this.extractAllocation(jsonData);
        this.interventionModel = this.extractInterventionModel(jsonData);
        this.masking = this.extractMasking(jsonData);
        this.primaryPurpose = this.extractPrimaryPurpose(jsonData);
        
        // Extract outcome data
        this.outcomes = this.extractOutcomes(jsonData);
    }
    
    extractId(jsonData) {
        return jsonData.protocolSection?.identificationModule?.nctId || 
               `Trial_${this.fileName.replace(/\.[^/.]+$/, "")}`;
    }
    
    extractTitle(jsonData) {
        return jsonData.protocolSection?.identificationModule?.briefTitle || 
               jsonData.protocolSection?.identificationModule?.officialTitle || 
               'Untitled Trial';
    }
    
    extractStatus(jsonData) {
        return jsonData.protocolSection?.statusModule?.overallStatus || 'Unknown';
    }
    
    extractPhase(jsonData) {
        const phases = jsonData.protocolSection?.designModule?.phases;
        if (Array.isArray(phases) && phases.length > 0) {
            return phases.join(', ');
        }
        return 'Not specified';
    }
    
    extractEnrollment(jsonData) {
        return jsonData.protocolSection?.designModule?.enrollmentInfo?.count || 0;
    }
    
    extractTargetEnrollment(jsonData) {
        // For trials that haven't completed enrollment, target might differ from actual
        if (this.status.toUpperCase() === 'RECRUITING' || 
            this.status.toUpperCase() === 'NOT YET RECRUITING') {
            return jsonData.protocolSection?.designModule?.enrollmentInfo?.count || 0;
        }
        return 0;
    }
    
    extractCompletionRate(jsonData) {
        // Try to extract from participant flow
        if (jsonData.resultsSection?.participantFlowModule?.periods) {
            const periods = jsonData.resultsSection.participantFlowModule.periods;
            const overallPeriod = periods.find(p => p.title.includes('Overall') || p.title.includes('overall'));
            
            if (overallPeriod?.milestones) {
                const startedMilestone = overallPeriod.milestones.find(m => m.type === 'STARTED');
                const completedMilestone = overallPeriod.milestones.find(m => m.type === 'COMPLETED');
                
                if (startedMilestone?.achievements && completedMilestone?.achievements) {
                    // Sum participants across all groups
                    const started = startedMilestone.achievements.reduce(
                        (sum, a) => sum + parseInt(a.numSubjects || '0'), 0);
                    const completed = completedMilestone.achievements.reduce(
                        (sum, a) => sum + parseInt(a.numSubjects || '0'), 0);
                    
                    if (started > 0) {
                        return (completed / started) * 100;
                    }
                }
            }
        }
        
        return null;
    }
    
    extractStudyType(jsonData) {
        return jsonData.protocolSection?.designModule?.studyType || 'Not specified';
    }
    
    extractAllocation(jsonData) {
        return jsonData.protocolSection?.designModule?.designInfo?.allocation || 'Not specified';
    }
    
    extractInterventionModel(jsonData) {
        return jsonData.protocolSection?.designModule?.designInfo?.interventionModel || 'Not specified';
    }
    
    extractMasking(jsonData) {
        const maskingInfo = jsonData.protocolSection?.designModule?.designInfo?.maskingInfo;
        if (maskingInfo) {
            const whoMasked = maskingInfo.whoMasked ? ` (${maskingInfo.whoMasked.join(', ')})` : '';
            return `${maskingInfo.masking}${whoMasked}`;
        }
        return 'Not specified';
    }
    
    extractPrimaryPurpose(jsonData) {
        return jsonData.protocolSection?.designModule?.designInfo?.primaryPurpose || 'Not specified';
    }
    
    extractOutcomes(jsonData) {
        if (!jsonData.resultsSection || !jsonData.resultsSection.outcomeMeasuresModule) {
            return [];
        }
        
        const outcomeMeasures = jsonData.resultsSection.outcomeMeasuresModule.outcomeMeasures || [];
        return outcomeMeasures.map((outcome, index) => {
            return new OutcomeData(outcome, `outcome-${index}`);
        });
    }
    
    isValid() {
        // A trial is valid if it has at least one outcome with data
        return this.outcomes.some(outcome => outcome.hasData());
    }
    
    getOutcomesByType(type) {
        return this.outcomes.filter(outcome => outcome.type === type);
    }
    
    getCompletionRate() {
        return this.completionRate || 0;
    }
    
    getSuccessRate() {
        // Calculate overall success rate based on primary outcomes
        const primaryOutcomes = this.getOutcomesByType('PRIMARY');
        if (primaryOutcomes.length === 0) return null;
        
        let successSum = 0;
        let validOutcomes = 0;
        
        primaryOutcomes.forEach(outcome => {
            if (outcome.hasData()) {
                // Calculate average success across groups
                const endpointValues = outcome.getEndpointValues();
                if (endpointValues.length > 0) {
                    // For each group, calculate improvement from baseline
                    const improvements = endpointValues.map(ev => {
                        const baselineValue = outcome.getBaselineValue(ev.group);
                        if (baselineValue !== null) {
                            // Calculate percent improvement
                            const change = ev.value - baselineValue;
                            const percentChange = (baselineValue !== 0) ? 
                                (change / Math.abs(baselineValue)) * 100 : 0;
                            
                            // Invert if lower is better
                            return outcome.isLowerBetter ? -percentChange : percentChange;
                        }
                        return null;
                    }).filter(v => v !== null);
                    
                    if (improvements.length > 0) {
                        // Average improvement across groups
                        successSum += improvements.reduce((a, b) => a + b, 0) / improvements.length;
                        validOutcomes++;
                    }
                }
            }
        });
        
        return validOutcomes > 0 ? successSum / validOutcomes : null;
    }
};

// OutcomeData class - used by TrialData
class OutcomeData {
    constructor(outcomeData, id) {
        this.id = id;
        this.type = outcomeData.type || 'OTHER';
        this.title = outcomeData.title || 'Untitled Outcome';
        this.description = outcomeData.description || '';
        this.timeFrame = outcomeData.timeFrame || '';
        this.paramType = outcomeData.paramType || '';
        this.unitOfMeasure = outcomeData.unitOfMeasure || '';
        this.reportingStatus = outcomeData.reportingStatus || '';
        
        // Determine if lower is better based on outcome name
        this.isLowerBetter = this.determineIfLowerIsBetter(this.title);
        
        // Extract groups
        this.groups = outcomeData.groups?.map(g => ({
            id: g.id,
            title: g.title,
            description: g.description || ''
        })) || [];
        
        // Process outcome measurements
        this.processOutcomeMeasurements(outcomeData);
    }
    
    determineIfLowerIsBetter(title) {
        if (!title) return false;
        
        const lowerIsBetterKeywords = [
            'pain', 'symptom', 'fatigue', 'depression', 'anxiety', 'madrs', 'hama', 'hamd', 
            'adverse', 'side effect', 'violence', 'victimization', 'risk', 'drinking'
        ];
        
        const outcomeLower = title.toLowerCase();
        return lowerIsBetterKeywords.some(keyword => outcomeLower.includes(keyword));
    }
    
    processOutcomeMeasurements(outcomeData) {
        this.values = [];              // For single time-point measurements
        this.valuesByTime = {};        // For time-series measurements
        this.analyses = [];            // Statistical analyses
        
        // Check if the outcome has any classes (data)
        if (!outcomeData.classes || outcomeData.classes.length === 0) {
            return;
        }
        
        // Process analyses if present
        if (outcomeData.analyses && outcomeData.analyses.length > 0) {
            this.analyses = outcomeData.analyses.map(analysis => ({
                groups: analysis.groupIds || [],
                pValue: analysis.pValue || null,
                method: analysis.statisticalMethod || '',
                comment: analysis.statisticalComment || '',
                paramType: analysis.paramType || '',
                paramValue: analysis.paramValue || null,
                ciPctValue: analysis.ciPctValue || null,
                ciLowerLimit: analysis.ciLowerLimit || null,
                ciUpperLimit: analysis.ciUpperLimit || null
            }));
        }
        
        // Check for time-based structure (classes with titles like "Baseline", "Week 6", etc.)
        const hasTimeBasedClasses = outcomeData.classes.some(cls => 
            cls.title && (
                cls.title.toLowerCase().includes('baseline') || 
                cls.title.toLowerCase().includes('month') ||
                cls.title.toLowerCase().includes('week') ||
                cls.title.toLowerCase().includes('day') ||
                cls.title.toLowerCase().includes('hour')
            )
        );
        
        if (hasTimeBasedClasses) {
            // Process as time-series data
            outcomeData.classes.forEach(cls => {
                if (!cls.title || !cls.categories) return;
                
                const timePoint = cls.title;
                this.valuesByTime[timePoint] = [];
                
                cls.categories.forEach(cat => {
                    if (!cat.measurements) return;
                    
                    cat.measurements.forEach(m => {
                        if (m.value === undefined || m.value === null || m.value === "") return;
                        
                        // Find group name
                        const group = this.groups.find(g => g.id === m.groupId)?.title || `Group ${m.groupId}`;
                        
                        // Add measurement
                        this.valuesByTime[timePoint].push({
                            group: group,
                            value: parseFloat(m.value),
                            spread: m.spread !== undefined ? parseFloat(m.spread) : undefined
                        });
                    });
                });
            });
        } else {
            // Process as single time-point data
            outcomeData.classes.forEach(cls => {
                if (!cls.categories) return;
                
                cls.categories.forEach(cat => {
                    if (!cat.measurements) return;
                    
                    cat.measurements.forEach(m => {
                        if (m.value === undefined || m.value === null || m.value === "") return;
                        
                        // Find group name
                        const group = this.groups.find(g => g.id === m.groupId)?.title || `Group ${m.groupId}`;
                        
                        // Add measurement
                        this.values.push({
                            group: group,
                            value: parseFloat(m.value),
                            spread: m.spread !== undefined ? parseFloat(m.spread) : undefined
                        });
                    });
                });
            });
        }
    }
    
    hasData() {
        return (this.values && this.values.length > 0) || 
               (this.valuesByTime && Object.keys(this.valuesByTime).length > 0);
    }
    
    getEndpointValues() {
        // If time-series data, use the last time point
        if (this.valuesByTime && Object.keys(this.valuesByTime).length > 0) {
            const timePoints = Object.keys(this.valuesByTime);
            
            // Sort time points (try to handle numeric and text-based time points)
            timePoints.sort((a, b) => {
                // Try to extract numeric values for comparison
                const aNum = parseFloat(a.match(/(\d+)/) ? a.match(/(\d+)/)[0] : a);
                const bNum = parseFloat(b.match(/(\d+)/) ? b.match(/(\d+)/)[0] : b);
                
                if (!isNaN(aNum) && !isNaN(bNum)) return aNum - bNum;
                return a.localeCompare(b);
            });
            
            // Return values from the last time point
            return this.valuesByTime[timePoints[timePoints.length - 1]] || [];
        }
        
        // Otherwise, use single values
        return this.values || [];
    }
    
    getBaselineValue(group) {
        if (!this.valuesByTime) return null;
        
        // Find baseline or similar time point
        const baselineKey = Object.keys(this.valuesByTime).find(key => 
            key.toLowerCase().includes('baseline') || 
            key.toLowerCase().includes('pre') || 
            key.toLowerCase().includes('start')
        );
        
        if (!baselineKey) return null;
        
        // Find value for the specified group
        const measurement = this.valuesByTime[baselineKey].find(m => m.group === group);
        return measurement ? measurement.value : null;
    }
}

// ChartManager class
window.ChartManager = class ChartManager {
    constructor() {
        this.charts = {};
        this.fullscreenChart = null;
        // Make sure to register Chart.js plugins when the page loads
        this.registerPlugins();
        this.colors = [
            'rgba(59, 130, 246, 0.7)',  // Blue
            'rgba(234, 88, 12, 0.7)',   // Orange
            'rgba(16, 185, 129, 0.7)',  // Green
            'rgba(168, 85, 247, 0.7)',  // Purple
            'rgba(239, 68, 68, 0.7)',   // Red
            'rgba(245, 158, 11, 0.7)',  // Amber
            'rgba(14, 165, 233, 0.7)',  // Sky
            'rgba(249, 115, 22, 0.7)',  // Orange
            'rgba(236, 72, 153, 0.7)',  // Pink
            'rgba(79, 70, 229, 0.7)'    // Indigo
        ];
    }
    
    registerPlugins() {
        // This will be called when the HTML loads
        // Make sure Chart.js and its plugins are properly loaded
    }
    
    getColor(index, solid = false) {
        const colorIndex = index % this.colors.length;
        return solid ? this.colors[colorIndex].replace('0.7', '1') : this.colors[colorIndex];
    }
    
    destroyAllCharts() {
        for (const chartId in this.charts) {
            if (this.charts[chartId]) {
                this.charts[chartId].destroy();
                delete this.charts[chartId];
            }
        }
        
        if (this.fullscreenChart) {
            this.fullscreenChart.destroy();
            this.fullscreenChart = null;
        }
    }
    
    // Additional Chart methods are already defined in the HTML file
};

// UIManager class
window.UIManager = class UIManager {
    constructor() {
        this.alertTimeout = null;
        this.progressInterval = null;
    }
    
    // UI methods are already defined in the HTML file
};

console.log("Module initialization complete");
    </script>

    <!-- Module import shims -->
    <!-- <script type="module">
        // Shim to allow import from modules defined in the same HTML file
        const modules = {};
        
        // Module: TrialData.js
        modules['./modules/TrialData.js'] = {
            TrialData: window.TrialData
        };
        
        // Module: ChartManager.js
        modules['./modules/ChartManager.js'] = {
            ChartManager: window.ChartManager
        };
        
        // Module: UIManager.js
        modules['./modules/UIManager.js'] = {
            UIManager: window.UIManager
        };
        
        // Override import function
        window.require = function(module) {
            if (modules[module]) {
                return modules[module];
            }
            
            throw new Error(`Module not found: ${module}`);
        };
    </script> -->
</body>
</html>