<!DOCTYPE html>
<html lang="en">
 <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRD Clinical Trials Outcomes Research Tool</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Axios for API requests -->
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#3b82f6',
                        'secondary': '#10b981',
                        'accent': '#8b5cf6',
                        'dark': '#1e293b',
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-gray-50 font-sans text-gray-800">
    <header class="bg-dark text-white shadow-md">
        <div class="container mx-auto p-4">
            <h1 class="text-3xl font-bold text-center">Treatment-Resistant Depression Clinical Trials Research Tool</h1>
            <p class="text-center text-gray-300 mt-2">Analyze and compare clinical trial outcomes across studies and phases</p>
        </div>
    </header>

    <main class="container mx-auto p-4">
        <!-- Search Section -->
        <section class="bg-white rounded-lg shadow-md p-6 mb-6">
            <h2 class="text-xl font-semibold mb-4">Search for Clinical Trials</h2>
            <div class="flex flex-col md:flex-row gap-4">
                <div class="flex-grow">
                    <label for="drugSearch" class="block text-sm font-medium mb-1">Drug Name:</label>
                    <input type="text" id="drugSearch" placeholder="e.g., PCN-101, Ketamine, COMP360" 
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary">
                </div>
                <div class="flex-grow">
                    <label for="conditionSearch" class="block text-sm font-medium mb-1">Condition (Optional):</label>
                    <input type="text" id="conditionSearch" placeholder="Default: Treatment Resistant Depression" 
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary">
                </div>
                <div class="flex items-end">
                    <button id="searchButton" class="bg-primary hover:bg-blue-600 text-white py-2 px-6 rounded-lg transition duration-200 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                        </svg>
                        Search
                    </button>
                </div>
            </div>
            <div class="mt-4 flex items-center gap-4">
                <div>
                    <input type="checkbox" id="hasResultsOnly" class="mr-2" checked>
                    <label for="hasResultsOnly" class="text-sm">Show only studies with results</label>
                </div>
                <div>
                    <input type="checkbox" id="trdFocusOnly" class="mr-2" checked>
                    <label for="trdFocusOnly" class="text-sm">Focus on TRD-specific trials only</label>
                </div>
            </div>
        </section>

        <!-- Loading State -->
        <div id="loadingState" class="hidden">
            <div class="flex justify-center items-center p-10">
                <svg class="animate-spin h-10 w-10 text-primary" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span class="ml-3 text-lg font-medium">Loading studies...</span>
            </div>
        </div>

        <!-- Placeholder Message -->
        <div id="placeholderMessage" class="bg-white rounded-lg shadow-md p-10 text-center text-gray-500">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mx-auto text-gray-400 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
            </svg>
            <p class="text-lg">Enter a drug name and click "Search" to analyze clinical trials</p>
            <p class="mt-2 text-sm">Example searches: Ketamine, Psilocybin, Esketamine, PCN-101, COMP360</p>
        </div>
        <div id="trial-dashboard" class="max-w-6xl mx-auto p-4" style="display: none;">
            <!-- Content will be dynamically populated by JavaScript -->
            <div class="animate-pulse flex flex-col space-y-4">
                <div class="h-8 bg-gray-200 rounded w-3/4 mx-auto"></div>
                <div class="h-4 bg-gray-200 rounded w-1/2 mx-auto"></div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="h-64 bg-gray-200 rounded"></div>
                    <div class="h-64 bg-gray-200 rounded"></div>
                    <div class="h-64 bg-gray-200 rounded"></div>
                    <div class="h-64 bg-gray-200 rounded"></div>
                </div>
                <div class="h-32 bg-gray-200 rounded"></div>
            </div>
        </div>

        <section id="fdaDataSection" class="hidden mb-6">
            <div class="bg-white rounded-lg shadow-md p-6">
              <h2 class="text-xl font-semibold mb-4">FDA Regulatory Information</h2>
              
              <div class="mb-6">
                <div class="flex items-center justify-between">
                  <h3 class="text-lg font-medium">FDA Documents</h3>
                  <span class="text-xs px-2 py-1 bg-blue-100 text-blue-800 rounded-full" id="fdaDocCount">0 documents</span>
                </div>
                <div class="mt-3 p-4 bg-gray-50 rounded-lg" id="fdaDocuments">
                  <div class="flex justify-center items-center py-8 text-gray-500">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mr-2 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                    </svg>
                    <span>FDA document data will be available here</span>
                  </div>
                </div>
              </div>
              
              <div class="mb-6">
                <div class="flex items-center justify-between">
                  <h3 class="text-lg font-medium">Orange Book Information</h3>
                  <span class="text-xs px-2 py-1 bg-orange-100 text-orange-800 rounded-full" id="orangeBookCount">0 entries</span>
                </div>
                <div class="mt-3 p-4 bg-gray-50 rounded-lg" id="orangeBookData">
                  <div class="flex justify-center items-center py-8 text-gray-500">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mr-2 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
                    </svg>
                    <span>Orange Book listings will be available here</span>
                  </div>
                </div>
              </div>
              
              <div class="mb-6">
                <div class="flex items-center justify-between">
                  <h3 class="text-lg font-medium">DailyMed Information</h3>
                  <span class="text-xs px-2 py-1 bg-green-100 text-green-800 rounded-full" id="dailyMedCount">0 entries</span>
                </div>
                <div class="mt-3 p-4 bg-gray-50 rounded-lg" id="dailyMedData">
                  <div class="flex justify-center items-center py-8 text-gray-500">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mr-2 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 8v8m-4-5v5m-4-2v2m-2 4h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                    </svg>
                    <span>DailyMed information will be available here</span>
                  </div>
                </div>
              </div>
              
              <div class="mb-3">
                <div class="flex items-center justify-between">
                  <h3 class="text-lg font-medium">FDA Warning Letters</h3>
                  <span class="text-xs px-2 py-1 bg-red-100 text-red-800 rounded-full" id="warningLettersCount">0 letters</span>
                </div>
                <div class="mt-3 p-4 bg-gray-50 rounded-lg" id="warningLettersData">
                  <div class="flex justify-center items-center py-8 text-gray-500">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mr-2 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                    </svg>
                    <span>Warning letters will be available here</span>
                  </div>
                </div>
              </div>
              
              <div class="text-center mt-6">
                <p class="text-sm text-gray-500">
                  Data sourced from FDA.gov, DailyMed, and FDA Orange Book. Last updated: March 2025
                </p>
              </div>
            </div>
          </section>

        <div class="bg-white p-4 rounded-lg shadow mb-6 hidden">
            <div class="flex flex-col md:flex-row gap-4">
              <div class="flex-1">
                <label for="trial-selection" class="block text-sm font-medium text-gray-700 mb-1">Select a trial</label>
                <select id="trial-selection" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                  <option value="">-- Select a trial --</option>
                </select>
              </div>
              <div class="flex items-end">
                <button id="visualize-btn" class="w-full md:w-auto px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                  Visualize Trial
                </button>
              </div>
            </div>
            <div class="mt-4" id="loading-indicator" style="display: none;">
              <div class="flex items-center justify-center">
                <svg class="animate-spin h-5 w-5 text-indigo-600 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                  <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span>Generating visualization...</span>
              </div>
            </div>
         
          
          <!-- Empty div that will be populated with visualization -->
          <div id="visualization-container" class="bg-white p-4 rounded-lg shadow min-h-[500px]"></div>
        </div>
      

<!-- Overall Drug Success Rate Section -->
<section id="drugSuccessSection" style="border: 1px solid blue;" class="hidden mb-6" style="display: none;">
    <div class="bg-white rounded-lg shadow-md p-6">
      <h2 class="text-xl font-semibold mb-4">Overall Drug Success Rates</h2>
      
      <div class="mb-6">
        <h3 class="text-lg font-medium mb-3">Treatment Efficacy Comparison Across Trials</h3>
        <p class="text-sm text-gray-600 mb-4">This visualization combines data from all trials to show overall effectiveness of treatments. Higher values indicate better outcomes relative to placebo.</p>
        <div class="h-72">
          <canvas id="overallDrugSuccessChart"></canvas>
        </div>
      </div>
  
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
        <div>
          <h3 class="text-lg font-medium mb-3">Response Rate Distribution</h3>
          <p class="text-sm text-gray-600 mb-2">Percentage of patients who responded to treatment</p>
          <div class="h-64">
            <canvas id="responseRateChart"></canvas>
          </div>
        </div>
        <div>
          <h3 class="text-lg font-medium mb-3">Remission Rate Distribution</h3>
          <p class="text-sm text-gray-600 mb-2">Percentage of patients who achieved remission</p>
          <div class="h-64">
            <canvas id="remissionRateChart"></canvas>
          </div>
        </div>
      </div>
      
      <div class="mb-6">
        <h3 class="text-lg font-medium mb-3">Statistical Summary by Drug</h3>
        <div class="overflow-x-auto">
          <table class="min-w-full bg-white border border-gray-200">
            <thead>
              <tr>
                <th class="py-2 px-4 border-b text-left">Drug</th>
                <th class="py-2 px-4 border-b text-left">Trials</th>
                <th class="py-2 px-4 border-b text-left">Total Patients</th>
                <th class="py-2 px-4 border-b text-left">Avg. Effect Size</th>
                <th class="py-2 px-4 border-b text-left">Response Rate</th>
                <th class="py-2 px-4 border-b text-left">Remission Rate</th>
              </tr>
            </thead>
            <tbody id="drugSuccessSummaryTable">
              <!-- Will be populated dynamically -->
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </section>
        <!-- Results Overview -->
        <section id="resultsOverview" class="hidden mb-6">
            <div class="bg-white rounded-lg shadow-md p-6">
                <h2 class="text-xl font-semibold mb-4">Results Overview</h2>
                <div id="resultsSummary" class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
                    <!-- Will be populated dynamically -->
                </div>
                <div class="flex flex-wrap gap-2 mb-4" id="phaseFilter">
                    <button class="phase-filter bg-primary text-white px-3 py-1 rounded-full text-sm" data-phase="all">All Phases</button>
                    <button class="phase-filter bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded-full text-sm" data-phase="PRE_PHASE">Pre-Phase</button>
                    <button class="phase-filter bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded-full text-sm" data-phase="PHASE1">Phase 1</button>
                    <button class="phase-filter bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded-full text-sm" data-phase="PHASE2">Phase 2</button>
                    <button class="phase-filter bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded-full text-sm" data-phase="PHASE3">Phase 3</button>
                    <button class="phase-filter bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded-full text-sm" data-phase="PHASE4">Phase 4</button>
                    <button class="phase-filter bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded-full text-sm" data-phase="PHASE1_PHASE2">Phase 1/2</button>
                </div>
            </div>
        </section>

        <!-- Collated Outcomes Section -->
<!-- Enhanced Collated Outcomes Section -->
<section id="collatedOutcomesSectxion" style="border: 1px solid red;" class="hidden mb-6" style="display: none;">
    <div class="bg-white rounded-lg shadow-md p-6">
      <h2 class="text-xl font-semibold mb-4">Collated Trial Outcomes</h2>
      
      <div class="mb-6">
        <h3 class="text-lg font-medium mb-3">Overall Treatment Effect Distribution</h3>
        <div class="flex justify-between mb-4">
          <div>
            <select id="outcomeMetricSelector" class="p-2 border border-gray-300 rounded-lg">
              <!-- Will be populated dynamically -->
            </select>
          </div>
          <div>
            <select id="outcomeTypeSelector" class="p-2 border border-gray-300 rounded-lg">
              <option value="all">All Outcomes</option>
              <option value="primary" selected>Primary Outcomes</option>
              <option value="secondary">Secondary Outcomes</option>
            </select>
          </div>
        </div>
        <div class="h-72">
          <canvas id="overallTreatmentEffectChart"></canvas>
        </div>
      </div>
      
      <div class="mb-6">
        <h3 class="text-lg font-medium mb-3">Phase Comparison</h3>
        <p class="text-sm text-gray-600 mb-4">Compare effect sizes across different clinical trial phases. Higher values indicate better outcomes.</p>
        <div class="h-72">
          <canvas id="phaseComparisonChart"></canvas>
        </div>
      </div>
      
      <div class="mb-6">
        <h3 class="text-lg font-medium mb-3">Comparative Phase Performance</h3>
        <p class="text-sm text-gray-600 mb-4">Direct comparison of phase-specific effect sizes with confidence intervals.</p>
        <div class="h-72">
          <canvas id="phasePerformanceChart"></canvas>
        </div>
      </div>
      
      <div class="mt-8">
        <h3 class="text-lg font-medium mb-3">Statistical Summary</h3>
        <div class="overflow-x-auto">
          <table class="min-w-full bg-white border border-gray-200">
            <thead>
              <tr>
                <th class="py-2 px-4 border-b text-left">Phase</th>
                <th class="py-2 px-4 border-b text-left">Trials</th>
                <th class="py-2 px-4 border-b text-left">Mean Effect</th>
                <th class="py-2 px-4 border-b text-left">Standard Deviation</th>
                <th class="py-2 px-4 border-b text-left">95% CI</th>
                <th class="py-2 px-4 border-b text-left">p-value</th>
              </tr>
            </thead>
            <tbody id="statisticalSummaryTable">
              <!-- Will be populated dynamically -->
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </section>
  
  <!-- New FDA Data Section -->


        <!-- Studies List -->
        <section id="studiesSection" class="hidden mb-6">
            <div class="bg-white rounded-lg shadow-md p-6">
                <h2 class="text-xl font-semibold mb-4">Studies (<span id="studyCount">0</span>)</h2>
                <div id="studiesList" class="space-y-4">
                    <!-- Will be populated dynamically -->
                </div>
            </div>
        </section>

        <!-- Aggregate Outcomes Section -->
        <section id="aggregateOutcomesSection" class="hidden mb-6">
            <div class="bg-white rounded-lg shadow-md p-6">
                <h2 class="text-xl font-semibold mb-4">Aggregate Outcomes by Phase</h2>
                
                <div class="mb-6">
                    <h3 class="text-lg font-medium mb-3">Overall Effectiveness Distribution</h3>
                    <canvas id="overallDistributionChart" height="300"></canvas>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="text-lg font-medium mb-3">Phase 1-2 Outcomes</h3>
                        <canvas id="earlyPhasesChart" height="250"></canvas>
                    </div>
                    <div>
                        <h3 class="text-lg font-medium mb-3">Phase 3-4 Outcomes</h3>
                        <canvas id="latePhasesChart" height="250"></canvas>
                    </div>
                </div>
                
                <div class="mt-6">
                    <h3 class="text-lg font-medium mb-3">Primary Outcome Measures Across Phases</h3>
                    <div id="outcomeMeasuresList" class="space-y-4">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
            </div>
        </section>

        <!-- Study Detail Section -->
        <section id="studyDetailSection" class="hidden mb-6">
            <div class="bg-white rounded-lg shadow-md p-6">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-semibold">Study Details</h2>
                    <button id="closeStudyDetail" class="text-gray-500 hover:text-gray-700">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <div id="studyDetailContent">
                    <!-- Will be populated dynamically -->
                </div>
            </div>
        </section>
    </main>

    <script>
        // API Base URL - Use our local backend
        const API_BASE_URL = "http://localhost:3000/api";

        // State management
        const appState = {
            studies: [],
            currentStudyId: null,
            currentPhaseFilter: 'all',
            allOutcomeMeasures: [],
            collatedOutcomes: [],
            hasResultsOnly: true,
            trdFocusOnly: true,
            studyDetails: {},
            outcomeMetrics: [],
            currentOutcomeMetric: '',
            currentOutcomeType: 'primary',
            failedStudyIds: new Set() // Track failed study ID requests to avoid repeated failures
        };
        appState.fdaData = {
    documents: [],
    orangeBook: [],
    dailyMed: [],
    warningLetters: []
};
appState.allTrialOutcomes = [];


        // DOM elements
        const elements = {
            drugSearch: document.getElementById('drugSearch'),
            conditionSearch: document.getElementById('conditionSearch'),
            hasResultsOnly: document.getElementById('hasResultsOnly'),
            trdFocusOnly: document.getElementById('trdFocusOnly'),
            searchButton: document.getElementById('searchButton'),
            loadingState: document.getElementById('loadingState'),
            placeholderMessage: document.getElementById('placeholderMessage'),
            resultsOverview: document.getElementById('resultsOverview'),
            resultsSummary: document.getElementById('resultsSummary'),
            studiesSection: document.getElementById('studiesSection'),
            studyCount: document.getElementById('studyCount'),
            studiesList: document.getElementById('studiesList'),
            aggregateOutcomesSection: document.getElementById('aggregateOutcomesSection'),
            collatedOutcomesSection: document.getElementById('collatedOutcomesSection'),
            studyDetailSection: document.getElementById('studyDetailSection'),
            closeStudyDetail: document.getElementById('closeStudyDetail'),
            studyDetailContent: document.getElementById('studyDetailContent'),
            phaseFilter: document.getElementById('phaseFilter'),
            outcomeMetricSelector: document.getElementById('outcomeMetricSelector'),
            outcomeTypeSelector: document.getElementById('outcomeTypeSelector'),
            statisticalSummaryTable: document.getElementById('statisticalSummaryTable')
        
        };
        elements.fdaDataSection = document.getElementById('fdaDataSection');
elements.fdaDocuments = document.getElementById('fdaDocuments');
elements.orangeBookData = document.getElementById('orangeBookData');
elements.dailyMedData = document.getElementById('dailyMedData');
elements.warningLettersData = document.getElementById('warningLettersData');
elements.fdaDocCount = document.getElementById('fdaDocCount');
elements.orangeBookCount = document.getElementById('orangeBookCount');
elements.dailyMedCount = document.getElementById('dailyMedCount');
elements.warningLettersCount = document.getElementById('warningLettersCount');
elements.phasePerformanceChart = document.getElementById('phasePerformanceChart');

        // Chart instances
        let charts = {
            overallDistribution: null,
            earlyPhases: null,
            latePhases: null,
            overallTreatmentEffect: null,
            phaseComparison: null,
            phasePerformance : null,
            studySpecific: {}
        };
// Add new elements to the DOM references
elements.drugSuccessSection = document.getElementById('drugSuccessSection');
elements.drugSuccessSummaryTable = document.getElementById('drugSuccessSummaryTable');

// Add new chart references
charts.overallDrugSuccess = null;
charts.responseRate = null;
charts.remissionRate = null;

// Function to analyze and display overall drug success rates
// Improved display function with error handling
function displayDrugSuccessRates() {
    console.log("Analyzing overall drug success rates...");
    
    try {
        // Only show if we have data
        if (appState.allTrialOutcomes.length === 0) {
            console.warn("No trial outcome data available for drug success visualization");
            return;
        }
        
        // Make sure the section is visible
        showSection(elements.drugSuccessSection, true);
        
        // Ensure chart canvases exist
        ensureDrugSuccessChartCanvasesExist();
        
        // Compute drug-specific data
        const drugData = analyzeDrugSuccessData();
        
        if (drugData.length === 0) {
            console.warn("No processed drug data available for visualization");
            elements.drugSuccessSection.querySelector('.bg-white').innerHTML = `
                <div class="text-center py-8">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mx-auto text-gray-400 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
                    </svg>
                    <p class="text-lg text-gray-600">Insufficient outcome data for drug success visualization</p>
                    <p class="mt-2 text-sm text-gray-500">Try searching for more studies or including studies without TRD focus</p>
                </div>
            `;
            return;
        }
        
        // Create visualizations
        createOverallDrugSuccessChart(drugData);
        createResponseRateChart(drugData);
        createRemissionRateChart(drugData);
        createDrugSuccessSummaryTable(drugData);
        
        // Create additional visualizations
        createCombinedMeasuresChart();
        createTreatmentOutcomeCurve();
        
    } catch (error) {
        console.error("Error in displayDrugSuccessRates:", error);
        
        // Add error message to drug success section
        if (elements.drugSuccessSection) {
            elements.drugSuccessSection.querySelector('.bg-white').innerHTML += `
                <div class="bg-red-50 text-red-700 p-4 rounded-lg mt-4">
                    <p>Error analyzing drug success rates: ${error.message}</p>
                    <p class="text-sm mt-2">This is likely due to an issue with the outcome data format.</p>
                </div>
            `;
        }
    }
}

// Function to ensure drug success chart canvases exist
function ensureDrugSuccessChartCanvasesExist() {
    // Get the drug success section
    const section = document.getElementById('drugSuccessSection');
    if (!section) {
        console.error("Drug success section not found");
        return;
    }
    
    // Define the chart canvases we need to check/create
    const chartCanvases = [
        { id: 'overallDrugSuccessChart', containerSelector: '.h-72' },
        { id: 'responseRateChart', containerSelector: '.h-64:nth-of-type(1)' },
        { id: 'remissionRateChart', containerSelector: '.h-64:nth-of-type(2)' }
    ];
    
    // Check each canvas
    chartCanvases.forEach(({ id, containerSelector }) => {
        // First check if the canvas already exists
        if (!document.getElementById(id)) {
            console.log(`Canvas ${id} not found, attempting to create`);
            
            // Find the container using the selector within the drug success section
            const containers = section.querySelectorAll(containerSelector);
            let container = null;
            
            if (containers && containers.length > 0) {
                // Use the first matching container
                container = containers[0];
            }
            
            // If we found a container, create the canvas inside it
            if (container) {
                container.innerHTML = `<canvas id="${id}"></canvas>`;
                console.log(`Created canvas: ${id}`);
            } else {
                console.error(`Container not found for ${id} using selector ${containerSelector}`);
                
                // Alternative approach: find container based on nearby heading text
                const headings = section.querySelectorAll('h3');
                for (let i = 0; i < headings.length; i++) {
                    const heading = headings[i];
                    
                    // Determine which heading might correspond to which chart
                    let targetId = null;
                    if (heading.textContent.includes("Treatment Effect") || 
                        heading.textContent.includes("Efficacy")) {
                        targetId = 'overallDrugSuccessChart';
                    } else if (heading.textContent.includes("Response Rate")) {
                        targetId = 'responseRateChart';
                    } else if (heading.textContent.includes("Remission Rate")) {
                        targetId = 'remissionRateChart';
                    }
                    
                    // If this heading matches our target and it's followed by a container
                    if (targetId === id && heading.nextElementSibling) {
                        const possibleContainer = heading.nextElementSibling;
                        possibleContainer.innerHTML = `<canvas id="${id}"></canvas>`;
                        console.log(`Created canvas ${id} in container after heading: ${heading.textContent}`);
                        break;
                    }
                }
            }
        }
    });
}

function updateNavigationBar() {
    const navbar = document.querySelector('.fixed.bottom-4');
    if (!navbar) return;
    
    // Check if we already have the drug success button
    if (!document.getElementById('nav-drug-success')) {
        const newButton = document.createElement('button');
        newButton.id = 'nav-drug-success';
        newButton.className = 'text-primary hover:text-blue-700 text-sm font-medium';
        newButton.textContent = 'Success Rates';
        
        // Insert before the FDA data button
        const fdaButton = document.getElementById('nav-fda');
        if (fdaButton) {
            navbar.querySelector('div').insertBefore(newButton, fdaButton);
        } else {
            navbar.querySelector('div').appendChild(newButton);
        }
        
        // Add event listener
        newButton.addEventListener('click', () => {
            elements.drugSuccessSection.scrollIntoView({ behavior: 'smooth' });
        });
    }
}

// Function to extract drug names from intervention data
function extractDrugName(studyTitle, measurements) {
    // Try to identify the drug from group titles first
    const experimentalGroups = measurements.filter(m => !m.isControlGroup);
    if (experimentalGroups.length > 0) {
        // Extract drug name from experimental group title
        const groupTitle = experimentalGroups[0].groupTitle.toLowerCase();
        
        // Look for common drug names
        const drugPatterns = [
            { pattern: /ketamine/i, name: "Ketamine" },
            { pattern: /esketamine/i, name: "Esketamine" },
            { pattern: /pcn-101/i, name: "PCN-101" },
            { pattern: /mij821/i, name: "MIJ821" },
            { pattern: /comp360/i, name: "COMP360" },
            { pattern: /psilocybin/i, name: "Psilocybin" },
            { pattern: /brexpiprazole/i, name: "Brexpiprazole" },
            { pattern: /quetiapine/i, name: "Quetiapine" }
        ];
        
        for (const { pattern, name } of drugPatterns) {
            if (pattern.test(groupTitle)) {
                return name;
            }
        }
    }
    
    // If not found in group titles, try to extract from study title
    const studyTitleLower = studyTitle.toLowerCase();
    for (const drugName of ["Ketamine", "Esketamine", "PCN-101", "MIJ821", "COMP360", "Psilocybin", "Brexpiprazole", "Quetiapine"]) {
        if (studyTitleLower.includes(drugName.toLowerCase())) {
            return drugName;
        }
    }
    
    // Default fallback
    return "Unknown";
}

// Function to analyze outcome data and calculate success metrics
function analyzeDrugSuccessData() {
    const drugData = {};
    
    // First group data by drug
    appState.allTrialOutcomes.forEach(study => {
        // Skip studies without outcomes
        if (!study.outcomes || study.outcomes.length === 0) return;
        
        // Process each outcome
        study.outcomes.forEach(outcome => {
            // Skip outcomes without measurement data
            if (!outcome.measurements || outcome.measurements.length === 0) return;
            
            // Extract drug name
            const drugName = extractDrugName(study.title, outcome.measurements);
            
            // Initialize drug data if needed
            if (!drugData[drugName]) {
                drugData[drugName] = {
                    name: drugName,
                    trials: new Set(),
                    totalPatients: 0,
                    effectSizes: [],
                    experimentalValues: [],
                    controlValues: [],
                    responseRates: [],
                    remissionRates: [],
                    outcomeMeasures: new Set()
                };
            }
            
            // Add this trial to the set
            drugData[drugName].trials.add(study.nctId);
            
            // Track outcome measure
            drugData[drugName].outcomeMeasures.add(outcome.title);
            
            // Add effect size if available
            if (outcome.effectSize !== null) {
                drugData[drugName].effectSizes.push(outcome.effectSize);
            }
            
            // Add experimental and control values
            if (outcome.experimentalValue !== null) {
                drugData[drugName].experimentalValues.push(outcome.experimentalValue);
                drugData[drugName].totalPatients += outcome.experimentalSampleSize || 0;
            }
            
            if (outcome.controlValue !== null) {
                drugData[drugName].controlValues.push(outcome.controlValue);
            }
            
            // Check for response and remission rates
            const titleLower = outcome.title.toLowerCase();
            const isResponseOutcome = titleLower.includes(">= 50% improvement") || 
                                     titleLower.includes("responders") || 
                                     titleLower.includes("response rate");
                                     
            const isRemissionOutcome = titleLower.includes("<= 10") || 
                                      titleLower.includes("remission") ||
                                      (titleLower.includes("madrs") && titleLower.includes("<=") && titleLower.includes("7"));
            
            // Extract the rates from measurements
            if (isResponseOutcome || isRemissionOutcome) {
                const experimentalMeasurements = outcome.measurements.filter(m => !m.isControlGroup);
                const controlMeasurements = outcome.measurements.filter(m => m.isControlGroup);
                
                if (experimentalMeasurements.length > 0) {
                    // For response/remission, measurements are usually percentages
                    const experimentalRate = experimentalMeasurements.reduce((sum, m) => sum + m.value, 0) / experimentalMeasurements.length;
                    
                    if (isResponseOutcome) {
                        drugData[drugName].responseRates.push(experimentalRate);
                    }
                    
                    if (isRemissionOutcome) {
                        drugData[drugName].remissionRates.push(experimentalRate);
                    }
                }
            }
        });
    });
    
    // Convert to array and calculate averages
    const result = Object.values(drugData).map(drug => {
        return {
            name: drug.name,
            trialCount: drug.trials.size,
            totalPatients: drug.totalPatients,
            avgEffectSize: drug.effectSizes.length > 0 ? calculateMean(drug.effectSizes) : null,
            stdDevEffectSize: drug.effectSizes.length > 0 ? calculateStandardDeviation(drug.effectSizes) : null,
            avgResponseRate: drug.responseRates.length > 0 ? calculateMean(drug.responseRates) : null,
            avgRemissionRate: drug.remissionRates.length > 0 ? calculateMean(drug.remissionRates) : null,
            outcomeMeasures: Array.from(drug.outcomeMeasures)
        };
    }).filter(drug => drug.trialCount > 0 && (drug.avgEffectSize !== null || drug.avgResponseRate !== null));
    
    // Sort by number of trials (descending)
    result.sort((a, b) => b.trialCount - a.trialCount);
    
    console.log("Analyzed drug success data:", result);
    
    return result;
}

// Function to create the overall drug success chart
function createOverallDrugSuccessChart(drugData) {
    const canvasId = 'overallDrugSuccessChart';
    const canvas = document.getElementById(canvasId);
    
    if (!canvas) {
        console.error(`Canvas not found: ${canvasId}`);
        return;
    }
    
    // Clear previous chart
    if (charts.overallDrugSuccess) {
        charts.overallDrugSuccess.destroy();
    }
    
    // Filter data to drugs with effect sizes
    const drugsWithEffectSizes = drugData.filter(drug => drug.avgEffectSize !== null);
    
    if (drugsWithEffectSizes.length === 0) {
        canvas.parentElement.innerHTML = '<p class="text-center text-gray-500 py-8">No effect size data available for comparison.</p>';
        return;
    }
    
    const ctx = canvas.getContext('2d');
    
    // Create bar chart for drug comparison
    charts.overallDrugSuccess = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: drugsWithEffectSizes.map(drug => drug.name),
            datasets: [{
                label: 'Average Effect Size',
                data: drugsWithEffectSizes.map(drug => drug.avgEffectSize),
                backgroundColor: drugsWithEffectSizes.map((_, i) => getColorByIndex(i, 0.7)),
                borderColor: drugsWithEffectSizes.map((_, i) => getColorByIndex(i)),
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y', // Horizontal bar chart
            scales: {
                x: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Effect Size (standardized)'
                    },
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Drug'
                    },
                    grid: {
                        display: false
                    }
                }
            },
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            return context[0].label;
                        },
                        label: function(context) {
                            const index = context.dataIndex;
                            const drug = drugsWithEffectSizes[index];
                            return [
                                `Effect Size: ${drug.avgEffectSize.toFixed(2)}`,
                                `Trials: ${drug.trialCount}`,
                                `Patients: ${drug.totalPatients}`
                            ];
                        }
                    }
                }
            }
        }
    });
}

// Function to create the response rate chart
function createResponseRateChart(drugData) {
    const canvasId = 'responseRateChart';
    const canvas = document.getElementById(canvasId);
    
    if (!canvas) {
        console.error(`Canvas not found: ${canvasId}`);
        return;
    }
    
    // Clear previous chart
    if (charts.responseRate) {
        charts.responseRate.destroy();
    }
    
    // Filter data to drugs with response rates
    const drugsWithResponseRates = drugData.filter(drug => drug.avgResponseRate !== null);
    
    if (drugsWithResponseRates.length === 0) {
        canvas.parentElement.innerHTML = '<p class="text-center text-gray-500 py-8">No response rate data available.</p>';
        return;
    }
    
    const ctx = canvas.getContext('2d');
    
    // Create pie chart for response rates
    charts.responseRate = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: drugsWithResponseRates.map(drug => drug.name),
            datasets: [{
                data: drugsWithResponseRates.map(drug => drug.avgResponseRate),
                backgroundColor: drugsWithResponseRates.map((_, i) => getColorByIndex(i, 0.7)),
                borderColor: drugsWithResponseRates.map((_, i) => getColorByIndex(i)),
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'right',
                    labels: {
                        boxWidth: 12
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const index = context.dataIndex;
                            const drug = drugsWithResponseRates[index];
                            return [
                                `${drug.name}: ${drug.avgResponseRate.toFixed(1)}%`,
                                `Trials: ${drug.trialCount}`
                            ];
                        }
                    }
                }
            }
        }
    });
}

// Function to create the remission rate chart
function createRemissionRateChart(drugData) {
    const canvasId = 'remissionRateChart';
    const canvas = document.getElementById(canvasId);
    
    if (!canvas) {
        console.error(`Canvas not found: ${canvasId}`);
        return;
    }
    
    // Clear previous chart
    if (charts.remissionRate) {
        charts.remissionRate.destroy();
    }
    
    // Filter data to drugs with remission rates
    const drugsWithRemissionRates = drugData.filter(drug => drug.avgRemissionRate !== null);
    
    if (drugsWithRemissionRates.length === 0) {
        canvas.parentElement.innerHTML = '<p class="text-center text-gray-500 py-8">No remission rate data available.</p>';
        return;
    }
    
    const ctx = canvas.getContext('2d');
    
    // Create pie chart for remission rates
    charts.remissionRate = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: drugsWithRemissionRates.map(drug => drug.name),
            datasets: [{
                data: drugsWithRemissionRates.map(drug => drug.avgRemissionRate),
                backgroundColor: drugsWithRemissionRates.map((_, i) => getColorByIndex(i, 0.7)),
                borderColor: drugsWithRemissionRates.map((_, i) => getColorByIndex(i)),
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'right',
                    labels: {
                        boxWidth: 12
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const index = context.dataIndex;
                            const drug = drugsWithRemissionRates[index];
                            return [
                                `${drug.name}: ${drug.avgRemissionRate.toFixed(1)}%`,
                                `Trials: ${drug.trialCount}`
                            ];
                        }
                    }
                }
            }
        }
    });
}

// Function to create the drug success summary table
function createDrugSuccessSummaryTable(drugData) {
    const table = elements.drugSuccessSummaryTable;
    if (!table) {
        console.error("Drug success summary table element not found");
        return;
    }
    
    table.innerHTML = '';
    
    if (drugData.length === 0) {
        table.innerHTML = '<tr><td colspan="6" class="py-4 text-center text-gray-500">No drug data available for summary.</td></tr>';
        return;
    }
    
    // Create a row for each drug
    drugData.forEach(drug => {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td class="py-2 px-4 border-b">${drug.name}</td>
            <td class="py-2 px-4 border-b">${drug.trialCount}</td>
            <td class="py-2 px-4 border-b">${drug.totalPatients}</td>
            <td class="py-2 px-4 border-b">${drug.avgEffectSize !== null ? drug.avgEffectSize.toFixed(2) : 'N/A'}</td>
            <td class="py-2 px-4 border-b">${drug.avgResponseRate !== null ? drug.avgResponseRate.toFixed(1) + '%' : 'N/A'}</td>
            <td class="py-2 px-4 border-b">${drug.avgRemissionRate !== null ? drug.avgRemissionRate.toFixed(1) + '%' : 'N/A'}</td>
        `;
        table.appendChild(row);
    });
}

// Helper function to get a color by index
function getColorByIndex(index, alpha = 1) {
    const colors = [
        `rgba(59, 130, 246, ${alpha})`,   // blue
        `rgba(16, 185, 129, ${alpha})`,   // emerald
        `rgba(139, 92, 246, ${alpha})`,   // violet
        `rgba(249, 115, 22, ${alpha})`,   // orange
        `rgba(236, 72, 153, ${alpha})`,   // pink
        `rgba(14, 165, 233, ${alpha})`,   // sky
        `rgba(168, 85, 247, ${alpha})`,   // purple
        `rgba(234, 88, 12, ${alpha})`,    // amber
        `rgba(22, 163, 74, ${alpha})`,    // green
        `rgba(79, 70, 229, ${alpha})`     // indigo
    ];
    
    return colors[index % colors.length];
}
        // Helper functions
        function displayLoading(show) {
            elements.loadingState.classList.toggle('hidden', !show);
            elements.placeholderMessage.classList.toggle('hidden', show);
        }

        function showSection(section, show = true) {
            section.classList.toggle('hidden', !show);
        }

        function formatPhase(phase) {
            if (!phase) return 'N/A';
            return phase
                .replace('PHASE', 'Phase ')
                .replace('PRE_', 'Pre-')
                .replace('_', '/');
        }

        function getPhaseColor(phase) {
            const colors = {
                'PRE_PHASE': '#9ca3af', // gray-400
                'PHASE1': '#60a5fa', // blue-400
                'PHASE2': '#34d399', // emerald-400
                'PHASE3': '#a78bfa', // violet-400
                'PHASE4': '#f97316', // orange-500
                'PHASE1_PHASE2': '#38bdf8' // sky-400
            };
            return colors[phase] || '#9ca3af';
        }

        function getStatusBadge(status) {
            const statusClasses = {
                'COMPLETED': 'bg-green-100 text-green-800',
                'RECRUITING': 'bg-blue-100 text-blue-800',
                'NOT_YET_RECRUITING': 'bg-yellow-100 text-yellow-800',
                'ACTIVE_NOT_RECRUITING': 'bg-indigo-100 text-indigo-800',
                'TERMINATED': 'bg-red-100 text-red-800',
                'WITHDRAWN': 'bg-gray-100 text-gray-800',
                'SUSPENDED': 'bg-orange-100 text-orange-800',
                'ENROLLING_BY_INVITATION': 'bg-purple-100 text-purple-800',
                'AVAILABLE': 'bg-teal-100 text-teal-800',
                'NO_LONGER_AVAILABLE': 'bg-gray-100 text-gray-800',
                'APPROVED_FOR_MARKETING': 'bg-green-100 text-green-800',
                'WITHHELD': 'bg-gray-100 text-gray-800',
                'UNKNOWN': 'bg-gray-100 text-gray-800'
            };

            const className = statusClasses[status] || 'bg-gray-100 text-gray-800';
            const label = status.replace(/_/g, ' ').toLowerCase();
            
            return `<span class="px-2 py-1 text-xs font-medium rounded-full ${className} capitalize">${label}</span>`;
        }

        // API functions
        async function fetchStudies(drug, condition, hasResults) {
            try {
                condition = condition || "Treatment Resistant Depression";
                
                // Using our backend endpoint
                const params = {
                    condition: condition,
                    intervention: drug,
                    hasResults: hasResults,
                    fields: "protocolSection,resultsSection,hasResults",
                    pageSize: 100
                };
                
                console.log("Fetching studies with params:", params);
                const response = await axios.get(`${API_BASE_URL}/studies/search`, { 
                    params,
                    headers: {
                        'Accept': 'application/json',
                        'Cache-Control': 'no-cache',
                        'Pragma': 'no-cache'
                    }
                });
                
                console.log("Studies search response status:", response.status);
                let studies = response.data.data.studies || [];
                
                return studies;
            } catch (error) {
                console.error("Error fetching studies:", error);
                return [];
            }
        }

        async function fetchStudyDetails(nctId) {
            // Skip if we've already failed to fetch this study
            if (appState.failedStudyIds.has(nctId)) {
                console.log(`Skipping already failed study ID: ${nctId}`);
                return null;
            }
            
            try {
                console.log(`Fetching details for study: ${nctId}`);
                const response = await axios.get(`${API_BASE_URL}/studies/${nctId}`, {
                    params: {
                        timestamp: new Date().getTime() // Add timestamp to prevent caching
                    },
                    headers: {
                        'Accept': 'application/json',
                        'Cache-Control': 'no-cache',
                        'Pragma': 'no-cache'
                    }
                });
                
                console.log(`Study details response status for ${nctId}:`, response.status);
                return response.data.data;
            } catch (error) {
                console.error(`Error fetching details for ${nctId}:`, error);
                appState.failedStudyIds.add(nctId); // Track failed requests
                return null;
            }
        }

        // Function to filter studies specific to TRD treatment
        function filterTRDSpecificStudies(studies) {
            if (!appState.trdFocusOnly) return studies;
            
            return studies.filter(study => {
                // Check if the study is specifically about TRD
                const title = study.protocolSection?.identificationModule?.briefTitle?.toLowerCase() || '';
                const officialTitle = study.protocolSection?.identificationModule?.officialTitle?.toLowerCase() || '';
                const briefSummary = study.protocolSection?.descriptionModule?.briefSummary?.toLowerCase() || '';
                const detailedDescription = study.protocolSection?.descriptionModule?.detailedDescription?.toLowerCase() || '';
                
                // Check for TRD-specific terms
                const trdTerms = [
                    'treatment-resistant depression', 
                    'treatment resistant depression',
                    'trd',
                    'refractory depression',
                    'treatment-refractory depression'
                ];
                
                // Check if any TRD terms are in the study's text
                return trdTerms.some(term => 
                    title.includes(term) || 
                    officialTitle.includes(term) || 
                    briefSummary.includes(term) || 
                    detailedDescription.includes(term)
                );
            });
        }

        // Function to generate bell curve data
        function generateNormalDistribution(mean, stdDev, points = 100) {
            if (isNaN(mean) || isNaN(stdDev) || stdDev <= 0) {
                console.warn("Invalid parameters for normal distribution:", { mean, stdDev });
                return [];
            }
            
            const data = [];
            const min = mean - 3 * stdDev;
            const max = mean + 3 * stdDev;
            const step = (max - min) / points;
            
            for (let x = min; x <= max; x += step) {
                const y = (1 / (stdDev * Math.sqrt(2 * Math.PI))) * 
                          Math.exp(-Math.pow(x - mean, 2) / (2 * Math.pow(stdDev, 2)));
                data.push({ x, y });
            }
            
            return data;
        }

        // Statistical utility functions
        function calculateMean(values) {
            if (!values || values.length === 0) return 0;
            return values.reduce((sum, val) => sum + val, 0) / values.length;
        }

        function calculateStandardDeviation(values, mean) {
            if (!values || values.length <= 1) return 0;
            mean = mean || calculateMean(values);
            const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
            return Math.sqrt(variance);
        }

        function calculateConfidenceInterval(mean, stdDev, n, confidenceLevel = 0.95) {
            if (n <= 1 || stdDev <= 0) return { lower: mean, upper: mean };
            
            // For small sample sizes, use t-distribution
            // Approximate t-value for 95% confidence and various degrees of freedom
            const tValue = n < 30 ? 2.045 : 1.96; // t-value for n-1 degrees of freedom at 95% confidence
            
            const marginOfError = tValue * (stdDev / Math.sqrt(n));
            return {
                lower: mean - marginOfError,
                upper: mean + marginOfError
            };
        }

        function calculatePValue(treatmentMean, controlMean, treatmentStdDev, controlStdDev, treatmentN, controlN) {
            // This is a simplified p-value calculation for demonstration
            // Would need proper t-test or other statistical test implementation for real applications
            if (treatmentN < 2 || controlN < 2) return "N/A";
            
            // Calculate pooled standard deviation
            const pooledVariance = ((treatmentN - 1) * Math.pow(treatmentStdDev, 2) + (controlN - 1) * Math.pow(controlStdDev, 2)) / 
                                (treatmentN + controlN - 2);
            const pooledStdDev = Math.sqrt(pooledVariance);
            
            // Calculate standard error of difference between means
            const standardError = pooledStdDev * Math.sqrt(1/treatmentN + 1/controlN);
            
            // Calculate t-statistic
            const tStat = Math.abs(treatmentMean - controlMean) / standardError;
            
            // Approximate p-value from t-statistic (simplified)
            // In a real implementation, would use t-distribution function
            if (tStat > 2.58) return "< 0.01";
            if (tStat > 1.96) return "< 0.05";
            return "> 0.05";
        }

        // Function to standardize outcome values for comparison
        function standardizeOutcomeValue(value, metric) {
            // For metrics where lower is better (e.g., depression scales), 
            // we invert the value for consistent interpretation
            const lowerIsBetterMetrics = [
                'hamilton depression rating scale',
                'madrs',
                'montgomery-asberg depression rating scale',
                'phq-9',
                'qids',
                'depression'
            ];
            
            if (lowerIsBetterMetrics.some(term => metric.toLowerCase().includes(term))) {
                // For these metrics, lower scores are better, so we invert the direction
                return -value;
            }
            
            return value;
        }

        // Function to extract and collate outcome measures
        function extractOutcomeMeasures(studies) {
            const allOutcomes = [];
            const outcomeMetrics = new Set();
            
            studies.forEach(study => {
                const nctId = study.protocolSection?.identificationModule?.nctId;
                if (!study.hasResults || !appState.studyDetails[nctId]) return;
                
                const studyDetail = appState.studyDetails[nctId];
                const phase = study.protocolSection?.designModule?.phases?.[0] || 'N/A';
                
                // Get outcome measures from the study results
                const outcomes = studyDetail.resultsSection?.outcomeMeasuresModule?.outcomeMeasures || [];
                
                // Process each outcome measure
                outcomes.forEach(outcome => {
                    // Skip outcomes without data
                    if (!outcome.classes || !outcome.classes[0]?.categories) return;
                    
                    // Add to unique metrics
                    outcomeMetrics.add(outcome.title);
                    
                    // Determine if this is a primary or secondary outcome
                    const outcomeType = outcome.type?.toLowerCase() || 'other';
                    
                    // Process each measurement class and category
                    outcome.classes.forEach(cls => {
                        cls.categories.forEach(cat => {
                            // Find experimental and control groups
                            const experimentalMeasurements = [];
                            const controlMeasurements = [];
                            
                            cat.measurements.forEach(measurement => {
                                const value = parseFloat(measurement.value);
                                
                                // Skip invalid measurements
                                if (isNaN(value)) return;
                                
                                // Determine if this is experimental or control group
                                const group = outcome.groups.find(g => g.id === measurement.groupId);
                                if (!group) return;
                                
                                const groupTitle = group.title.toLowerCase();
                                const isControlGroup = 
                                    groupTitle.includes('placebo') || 
                                    groupTitle.includes('control') ||
                                    groupTitle.includes('sham');
                                
                                // Calculate standard error if available
                                let standardError = null;
                                
                                if (measurement.dispersion && measurement.dispersion !== 'null') {
                                    const dispersionValue = parseFloat(measurement.dispersion);
                                    const dispersionType = measurement.dispersionType?.toLowerCase() || '';
                                    
                                    if (!isNaN(dispersionValue)) {
                                        if (dispersionType === 'standard_error') {
                                            standardError = dispersionValue;
                                        } else if (dispersionType === 'standard_deviation') {
                                            // Convert SD to SE if sample size is available
                                            const sampleSize = group.participantsAnalyzedList?.[0]?.count;
                                            if (sampleSize && !isNaN(sampleSize) && sampleSize > 0) {
                                                standardError = dispersionValue / Math.sqrt(sampleSize);
                                            }
                                        }
                                    }
                                }
                                
                                // Prepare measurement data
                                const measurementData = {
                                    value: value,
                                    standardError: standardError,
                                    sampleSize: group.participantsAnalyzedList?.[0]?.count || 0
                                };
                                
                                // Add to appropriate group
                                if (isControlGroup) {
                                    controlMeasurements.push(measurementData);
                                } else {
                                    experimentalMeasurements.push(measurementData);
                                }
                            });
                            
                            // Calculate aggregated measurements
                            if (experimentalMeasurements.length > 0) {
                                // Calculate weighted average for experimental group
                                const expTotal = experimentalMeasurements.reduce((sum, m) => sum + (m.value * m.sampleSize), 0);
                                const expSampleSize = experimentalMeasurements.reduce((sum, m) => sum + m.sampleSize, 0);
                                
                                let controlValue = null;
                                let controlSampleSize = 0;
                                
                                // Calculate weighted average for control group if available
                                if (controlMeasurements.length > 0) {
                                    const ctrlTotal = controlMeasurements.reduce((sum, m) => sum + (m.value * m.sampleSize), 0);
                                    controlSampleSize = controlMeasurements.reduce((sum, m) => sum + m.sampleSize, 0);
                                    
                                    if (controlSampleSize > 0) {
                                        controlValue = ctrlTotal / controlSampleSize;
                                    }
                                }
                                
                                // Calculate standardized outcome value
                                const experimentalValue = expSampleSize > 0 ? expTotal / expSampleSize : null;
                                
                                // Calculate effect size if both experimental and control values exist
                                let effectSize = null;
                                if (experimentalValue !== null && controlValue !== null) {
                                    // Standardize the effect based on outcome metric
                                    effectSize = standardizeOutcomeValue(experimentalValue - controlValue, outcome.title);
                                }
                                
                                // Store the outcome data
                                allOutcomes.push({
                                    nctId: nctId,
                                    title: study.protocolSection?.identificationModule?.briefTitle || 'Untitled Study',
                                    phase: phase,
                                    outcomeType: outcomeType,
                                    outcomeTitle: outcome.title,
                                    category: cat.title,
                                    experimentalValue: experimentalValue,
                                    controlValue: controlValue,
                                    effectSize: effectSize,
                                    experimentalSampleSize: expSampleSize,
                                    controlSampleSize: controlSampleSize,
                                    timeFrame: outcome.timeFrame || 'Not specified'
                                });
                            }
                        });
                    });
                });
            });
            
            // Set the outcome metrics and measures
            appState.collatedOutcomes = allOutcomes;
            appState.outcomeMetrics = Array.from(outcomeMetrics);
            
            // If we have any outcomes, set the default metric
            if (appState.outcomeMetrics.length > 0) {
                appState.currentOutcomeMetric = appState.outcomeMetrics[0];
            }
            
            // Populate the outcome metric selector
            populateOutcomeMetricSelector();
            
            // Display aggregate outcome visualizations
            displayAggregateVisualizations();
            
            // Display collated outcomes visualizations
            displayCollatedOutcomes();
        }
        
        function populateOutcomeMetricSelector() {
    if (!elements.outcomeMetricSelector) {
        elements.outcomeMetricSelector = document.getElementById('outcomeMetricSelector');
        if (!elements.outcomeMetricSelector) {
            console.error('Outcome metric selector not found, cannot populate');
            return;
        }
        
        // Re-add event listener
        elements.outcomeMetricSelector.addEventListener('change', () => {
            appState.currentOutcomeMetric = elements.outcomeMetricSelector.value;
            displayCollatedOutcomes();
        });
    }
    
    elements.outcomeMetricSelector.innerHTML = '';
    
    appState.outcomeMetrics.forEach(metric => {
        const option = document.createElement('option');
        option.value = metric;
        option.textContent = metric;
        elements.outcomeMetricSelector.appendChild(option);
    });
    
    // Set the current metric
    if (appState.currentOutcomeMetric) {
        elements.outcomeMetricSelector.value = appState.currentOutcomeMetric;
    }
}


        function displayResultsSummary(studies) {
            elements.resultsSummary.innerHTML = '';
            
            // Count studies by phase
            const phaseCount = studies.reduce((acc, study) => {
                const phase = study.protocolSection?.designModule?.phases?.[0] || 'N/A';
                acc[phase] = (acc[phase] || 0) + 1;
                return acc;
            }, {});
            
            // Count studies by status
            const statusCount = studies.reduce((acc, study) => {
                const status = study.protocolSection?.statusModule?.overallStatus || 'UNKNOWN';
                acc[status] = (acc[status] || 0) + 1;
                return acc;
            }, {});
            
            // Count studies with results
            const withResults = studies.filter(study => study.hasResults).length;
            
            // Calculate success rate for completed studies with results
            let successRate = "N/A";
            const completedWithResults = studies.filter(study => 
                study.hasResults && 
                study.protocolSection?.statusModule?.overallStatus === "COMPLETED"
            ).length;
            
            if (completedWithResults > 0) {
                // For now, just estimate based on positive outcomes in collated data
                const positiveOutcomes = appState.collatedOutcomes.filter(outcome => outcome.effectSize > 0).length;
                const totalOutcomes = appState.collatedOutcomes.length;
                
                if (totalOutcomes > 0) {
                    successRate = `${Math.round(positiveOutcomes * 100 / totalOutcomes)}%`;
                }
            }
            
            // Create summary cards
            const summaryItems = [
                {
                    title: 'Total Studies',
                    value: studies.length,
                    icon: '<svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-primary" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" /></svg>'
                },
                {
                    title: 'With Results',
                    value: withResults,
                    icon: '<svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-secondary" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" /></svg>'
                },
                {
                    title: 'Study Phases',
                    value: Object.keys(phaseCount).length,
                    icon: '<svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-accent" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" /></svg>'
                },
                {
                    title: 'Success Rate',
                    value: successRate,
                    icon: '<svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-green-500" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>'
                }
            ];
            
            summaryItems.forEach(item => {
                const card = document.createElement('div');
                card.className = 'bg-gray-50 rounded-lg p-4 flex items-center';
                card.innerHTML = `
                    <div class="p-3 rounded-full bg-white shadow-sm mr-4">
                        ${item.icon}
                    </div>
                    <div>
                        <p class="text-sm text-gray-500">${item.title}</p>
                        <p class="text-2xl font-semibold">${item.value}</p>
                    </div>
                `;
                elements.resultsSummary.appendChild(card);
            });
        }

        function displayStudies(studies) {
            elements.studiesList.innerHTML = '';
            elements.studyCount.textContent = studies.length;
            
            if (studies.length === 0) {
                elements.studiesList.innerHTML = `
                    <div class="text-center p-4 text-gray-500">
                        <p>No studies found matching the current filters.</p>
                    </div>
                `;
                return;
            }
            
            // Sort studies by phase
            const phaseOrder = { 
                "PRE_PHASE": 0, 
                "PHASE1": 1, 
                "PHASE1_PHASE2": 1.5,
                "PHASE2": 2, 
                "PHASE3": 3, 
                "PHASE4": 4 
            };
            
            studies.sort((a, b) => {
                const phaseA = a.protocolSection?.designModule?.phases?.[0] || "PRE_PHASE";
                const phaseB = b.protocolSection?.designModule?.phases?.[0] || "PRE_PHASE";
                return (phaseOrder[phaseA] || 0) - (phaseOrder[phaseB] || 0);
            });
            
            studies.forEach(study => {
                const nctId = study.protocolSection?.identificationModule?.nctId;
                const title = study.protocolSection?.identificationModule?.briefTitle;
                const phase = study.protocolSection?.designModule?.phases?.[0] || "N/A";
                const status = study.protocolSection?.statusModule?.overallStatus;
                const sponsor = study.protocolSection?.identificationModule?.organization?.fullName;
                const hasResults = study.hasResults;
                
                // Determine if this is a TRD-specific study
                const briefTitle = study.protocolSection?.identificationModule?.briefTitle?.toLowerCase() || '';
                const officialTitle = study.protocolSection?.identificationModule?.officialTitle?.toLowerCase() || '';
                const briefSummary = study.protocolSection?.descriptionModule?.briefSummary?.toLowerCase() || '';
                
                const trdTerms = [
                    'treatment-resistant depression', 
                    'treatment resistant depression',
                    'trd',
                    'refractory depression'
                ];
                
                const isTRDSpecific = trdTerms.some(term => 
                    briefTitle.includes(term) || 
                    officialTitle.includes(term) || 
                    briefSummary.includes(term)
                );
                
                const card = document.createElement('div');
                card.className = 'bg-white p-4 rounded-lg border border-gray-200 hover:shadow-md transition duration-200';
                card.innerHTML = `
                    <div class="flex flex-col md:flex-row gap-2 md:items-center md:justify-between mb-3">
                        <div class="flex gap-2 items-center flex-wrap">
                            <span class="inline-block w-3 h-3 rounded-full" style="background-color: ${getPhaseColor(phase)}"></span>
                            <span class="text-sm font-medium">${formatPhase(phase)}</span>
                            ${getStatusBadge(status)}
                            ${isTRDSpecific ? '<span class="text-xs bg-purple-100 text-purple-800 px-2 py-0.5 rounded-full">TRD-Specific</span>' : ''}
                        </div>
                        <div>
                            <span class="text-xs text-gray-500">${nctId}</span>
                            ${hasResults ? '<span class="ml-2 text-xs bg-green-100 text-green-800 px-2 py-0.5 rounded-full">Has Results</span>' : ''}
                        </div>
                    </div>
                    <h3 class="text-lg font-medium mb-2">${title}</h3>
                    <p class="text-sm text-gray-600 mb-3">Sponsor: ${sponsor || 'Unknown'}</p>
                    <button data-nctid="${nctId}" class="view-study-btn text-primary hover:text-blue-700 text-sm font-medium flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                        </svg>
                        View Study Details
                    </button>
                `;
                elements.studiesList.appendChild(card);
                
                // Add event listener to the view button
                card.querySelector('.view-study-btn').addEventListener('click', () => {
                    viewStudyDetails(nctId);
                });
            });
        }

        async function viewStudyDetails(nctId) {
            appState.currentStudyId = nctId;
            displayLoading(true);
            
            // Check if we already have the study details cached
            let studyDetails = appState.studyDetails[nctId];
            
            // If not cached, fetch from API
            if (!studyDetails) {
                studyDetails = await fetchStudyDetails(nctId);
                
                if (studyDetails) {
                    // Cache the study details
                    appState.studyDetails[nctId] = studyDetails;
                }
            }
            
            if (!studyDetails) {
                displayLoading(false);
                alert('Error loading study details. Please try again.');
                return;
            }
            
            // Display study details
            displayStudyDetail(studyDetails);
            
            // Show the detail section
            showSection(elements.studyDetailSection, true);
            elements.studyDetailSection.scrollIntoView({ behavior: 'smooth' });
            displayLoading(false);
        }

        function displayStudyDetail(study) {
            const identification = study.protocolSection?.identificationModule || {};
            const design = study.protocolSection?.designModule || {};
            const description = study.protocolSection?.descriptionModule || {};
            const arms = study.protocolSection?.armsInterventionsModule?.armGroups || [];
            const eligibility = study.protocolSection?.eligibilityModule || {};
            const outcomes = study.resultsSection?.outcomeMeasuresModule?.outcomeMeasures || [];
            
            const primaryOutcomes = outcomes.filter(outcome => outcome.type === "PRIMARY");
            const secondaryOutcomes = outcomes.filter(outcome => outcome.type === "SECONDARY");
            
            // Determine if this is a TRD-specific study
            const title = identification.briefTitle?.toLowerCase() || '';
            const officialTitle = identification.officialTitle?.toLowerCase() || '';
            const briefSummary = description.briefSummary?.toLowerCase() || '';
            const detailedDescription = description.detailedDescription?.toLowerCase() || '';
            
            const trdTerms = [
                'treatment-resistant depression', 
                'treatment resistant depression',
                'trd',
                'refractory depression',
                'treatment-refractory depression'
            ];
            
            const isTRDSpecific = trdTerms.some(term => 
                title.includes(term) || 
                officialTitle.includes(term) || 
                briefSummary.includes(term) || 
                detailedDescription.includes(term)
            );
            
            elements.studyDetailContent.innerHTML = `
        <div class="border-b pb-4 mb-4">
            <div class="flex justify-between items-start">
                <h2 class="text-2xl font-semibold mb-2">${identification.briefTitle || 'Untitled Study'}</h2>
                <button id="copyStudyData" class="text-primary hover:text-blue-700 flex items-center text-sm">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-4M16 5h2a2 2 0 012 2v4M21 14H11" />
                    </svg>
                    Copy Data
                </button>
            </div>
            <div class="flex flex-wrap gap-2 mb-2">
                <span class="bg-gray-100 text-sm px-3 py-1 rounded-full">NCT ID: ${identification.nctId || 'N/A'}</span>
                <span class="bg-gray-100 text-sm px-3 py-1 rounded-full">Phase: ${formatPhase(design.phases?.[0] || 'N/A')}</span>
                <span class="bg-gray-100 text-sm px-3 py-1 rounded-full">Status: ${study.protocolSection?.statusModule?.overallStatus || 'N/A'}</span>
                ${isTRDSpecific ? '<span class="bg-purple-100 text-purple-800 text-sm px-3 py-1 rounded-full">TRD-Specific</span>' : ''}
            </div>
            <p class="text-sm text-gray-600">Sponsor: ${identification.organization?.fullName || 'N/A'}</p>
        </div>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    <div>
                        <h3 class="text-lg font-medium mb-2">Study Design</h3>
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <p><strong>Study Type:</strong> ${design.studyType || 'N/A'}</p>
                            <p><strong>Allocation:</strong> ${design.designInfo?.allocation || 'N/A'}</p>
                            <p><strong>Intervention Model:</strong> ${design.designInfo?.interventionModel || 'N/A'}</p>
                            <p><strong>Masking:</strong> ${design.designInfo?.maskingInfo?.masking || 'N/A'}</p>
                            <p><strong>Primary Purpose:</strong> ${design.designInfo?.primaryPurpose || 'N/A'}</p>
                        </div>
                    </div>
                    
                    <div>
                        <h3 class="text-lg font-medium mb-2">Enrollment</h3>
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <p><strong>Enrollment:</strong> ${eligibility.expectedEnrollment || 'N/A'}</p>
                            <p><strong>Sex:</strong> ${eligibility.sex || 'N/A'}</p>
                            <p><strong>Minimum Age:</strong> ${eligibility.minimumAge || 'N/A'}</p>
                            <p><strong>Maximum Age:</strong> ${eligibility.maximumAge || 'N/A'}</p>
                            <p><strong>Healthy Volunteers:</strong> ${eligibility.healthyVolunteers || 'N/A'}</p>
                        </div>
                    </div>
                </div>
                
                <div class="mb-6">
                    <h3 class="text-lg font-medium mb-2">Brief Summary</h3>
                    <div class="bg-gray-50 p-3 rounded-lg">
                        <p>${description.briefSummary || 'No summary available.'}</p>
                    </div>
                </div>
                
                <div class="mb-6">
                    <h3 class="text-lg font-medium mb-2">Arms and Interventions</h3>
                    <div class="bg-gray-50 p-3 rounded-lg">
                        ${arms.length > 0 ? 
                            `<div class="grid grid-cols-1 gap-3">
                                ${arms.map(arm => `
                                    <div class="border-b border-gray-200 pb-3 last:border-b-0 last:pb-0">
                                        <p class="font-medium">${arm.label} (${arm.type})</p>
                                        <p class="text-sm">${arm.description || 'No description available.'}</p>
                                    </div>
                                `).join('')}
                            </div>` : 
                            '<p class="italic text-gray-500">No arms or interventions information available.</p>'
                        }
                    </div>
                </div>
                
                <div id="outcomeVisuals" class="mb-6">
                    <h3 class="text-lg font-medium mb-2">Outcome Measurements</h3>
                    ${outcomes.length > 0 ? 
                        `<div class="space-y-6">
                            ${primaryOutcomes.length > 0 ? 
                                `<div>
                                    <h4 class="text-md font-medium mb-2">Primary Outcomes</h4>
                                    <div class="space-y-4">
                                        ${primaryOutcomes.map((outcome, idx) => `
                                            <div class="bg-gray-50 p-3 rounded-lg">
                                                <p class="font-medium">${outcome.title}</p>
                                                <p class="text-sm mb-2">${outcome.description || 'No description available.'}</p>
                                                <p class="text-sm text-gray-600">Time Frame: ${outcome.timeFrame || 'Not specified'}</p>
                                                <div class="h-48 mt-3">
                                                    <canvas id="outcome_${identification.nctId}_${idx}"></canvas>
                                                </div>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>` : 
                                ''}
                            
                            ${secondaryOutcomes.length > 0 ? 
                                `<div>
                                    <h4 class="text-md font-medium mb-2">Secondary Outcomes</h4>
                                    <div class="space-y-4">
                                        ${secondaryOutcomes.map((outcome, idx) => `
                                            <div class="bg-gray-50 p-3 rounded-lg">
                                                <p class="font-medium">${outcome.title}</p>
                                                <p class="text-sm mb-2">${outcome.description || 'No description available.'}</p>
                                                <p class="text-sm text-gray-600">Time Frame: ${outcome.timeFrame || 'Not specified'}</p>
                                                <div class="h-48 mt-3">
                                                    <canvas id="outcome_secondary_${identification.nctId}_${idx}"></canvas>
                                                </div>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>` : 
                                ''}
                        </div>` : 
                        '<p class="italic text-gray-500">No outcome measurements available.</p>'
                    }
                </div>
                
                <div class="mt-6 text-center">
                    <a href="https://clinicaltrials.gov/study/${identification.nctId}" target="_blank" class="inline-flex items-center text-primary hover:text-blue-700">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                        </svg>
                        View full study on ClinicalTrials.gov
                    </a>
                            <button id="viewFdaData" class="text-primary hover:text-blue-700 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
                View FDA Data
            </button>
        </div>
            `;
            
            // Create outcome charts after content is added to DOM
            setTimeout(() => {
        createOutcomeCharts(study);
        
        // Add event listener for copy button
        const copyButton = document.getElementById('copyStudyData');
        if (copyButton) {
            copyButton.addEventListener('click', () => {
                copyTrialDataToClipboard(identification.nctId);
            });
        }
        
        // Add event listener for view FDA data button
        const viewFdaButton = document.getElementById('viewFdaData');
        if (viewFdaButton) {
            viewFdaButton.addEventListener('click', () => {
                // Scroll to FDA data section
                elements.fdaDataSection.scrollIntoView({ behavior: 'smooth' });
            });
        }
    }, 100);
}

function collectAllTrialOutcomes() {
    console.log("Collecting all trial outcomes data...");
    appState.allTrialOutcomes = [];
    
    // Get all studies with results
    const studiesWithResults = appState.studies.filter(study => study.hasResults);
    console.log(`Found ${studiesWithResults.length} studies with results`);
    
    // For each study, collect the outcome measures
    studiesWithResults.forEach(study => {
        const nctId = study.protocolSection?.identificationModule?.nctId;
        const studyDetails = appState.studyDetails[nctId];
        
        if (!studyDetails || !studyDetails.resultsSection?.outcomeMeasuresModule?.outcomeMeasures) {
            console.warn(`No outcome measures found for study ${nctId}`);
            return;
        }
        
        const phase = study.protocolSection?.designModule?.phases?.[0] || 'N/A';
        const studyTitle = study.protocolSection?.identificationModule?.briefTitle || 'Untitled Study';
        const outcomes = studyDetails.resultsSection.outcomeMeasuresModule.outcomeMeasures;
        
        console.log(`Processing ${outcomes.length} outcomes for study ${nctId} (${studyTitle})`);
        
        // Store basic study info
        const studyInfo = {
            nctId,
            title: studyTitle,
            phase,
            sponsor: study.protocolSection?.identificationModule?.organization?.fullName || 'Unknown',
            status: study.protocolSection?.statusModule?.overallStatus || 'Unknown',
            outcomes: []
        };
        
        // Process each outcome measure
        outcomes.forEach(outcome => {
            if (!outcome.classes || !outcome.classes[0]?.categories) {
                console.warn(`Skipping outcome with no categories: ${outcome.title}`);
                return;
            }
            
            const outcomeType = outcome.type?.toLowerCase() || 'other';
            const outcomeTitle = outcome.title || 'Unknown Outcome';
            const timeFrame = outcome.timeFrame || 'Not specified';
            
            // Process each measurement class and category
            outcome.classes.forEach(cls => {
                cls.categories.forEach(cat => {
                    const categoryData = {
                        title: cat.title || 'Unknown Category',
                        measurements: []
                    };
                    
                    // Extract all measurements
                    cat.measurements.forEach(measurement => {
                        const value = parseFloat(measurement.value);
                        if (isNaN(value)) return;
                        
                        const group = outcome.groups.find(g => g.id === measurement.groupId);
                        if (!group) return;
                        
                        const groupTitle = group.title || 'Unknown Group';
                        const isControlGroup = 
                            groupTitle.toLowerCase().includes('placebo') || 
                            groupTitle.toLowerCase().includes('control') ||
                            groupTitle.toLowerCase().includes('sham');
                        
                        // Calculate standard error or other statistics if available
                        let standardError = null;
                        let dispersion = null;
                        let dispersionType = null;
                        
                        if (measurement.dispersion && measurement.dispersion !== 'null') {
                            dispersion = parseFloat(measurement.dispersion);
                            dispersionType = measurement.dispersionType?.toLowerCase() || '';
                            
                            if (!isNaN(dispersion)) {
                                if (dispersionType === 'standard_error') {
                                    standardError = dispersion;
                                } else if (dispersionType === 'standard_deviation') {
                                    // Convert SD to SE if sample size is available
                                    const sampleSize = group.participantsAnalyzedList?.[0]?.count;
                                    if (sampleSize && !isNaN(sampleSize) && sampleSize > 0) {
                                        standardError = dispersion / Math.sqrt(sampleSize);
                                    }
                                }
                            }
                        }
                        
                        // Add measurement data
                        categoryData.measurements.push({
                            value,
                            groupId: measurement.groupId,
                            groupTitle,
                            isControlGroup,
                            sampleSize: group.participantsAnalyzedList?.[0]?.count || 0,
                            standardError,
                            dispersion,
                            dispersionType
                        });
                    });
                    
                    // Only add categories with measurements
                    if (categoryData.measurements.length > 0) {
                        // Calculate effect size if we have both experimental and control groups
                        const experimentalMeasurements = categoryData.measurements.filter(m => !m.isControlGroup);
                        const controlMeasurements = categoryData.measurements.filter(m => m.isControlGroup);
                        
                        let effectSize = null;
                        let experimentalValue = null;
                        let controlValue = null;
                        let experimentalSampleSize = 0;
                        let controlSampleSize = 0;
                        
                        if (experimentalMeasurements.length > 0) {
                            // Calculate weighted average for experimental group
                            const expTotal = experimentalMeasurements.reduce((sum, m) => sum + (m.value * m.sampleSize), 0);
                            experimentalSampleSize = experimentalMeasurements.reduce((sum, m) => sum + m.sampleSize, 0);
                            experimentalValue = experimentalSampleSize > 0 ? expTotal / experimentalSampleSize : null;
                        }
                        
                        if (controlMeasurements.length > 0) {
                            // Calculate weighted average for control group
                            const ctrlTotal = controlMeasurements.reduce((sum, m) => sum + (m.value * m.sampleSize), 0);
                            controlSampleSize = controlMeasurements.reduce((sum, m) => sum + m.sampleSize, 0);
                            controlValue = controlSampleSize > 0 ? ctrlTotal / controlSampleSize : null;
                        }
                        
                        // Calculate effect size if both values exist
                        if (experimentalValue !== null && controlValue !== null) {
                            // Standardize the effect based on outcome metric
                            effectSize = standardizeOutcomeValue(experimentalValue - controlValue, outcomeTitle);
                        }
                        
                        // Add the processed outcome data
                        studyInfo.outcomes.push({
                            title: outcomeTitle,
                            type: outcomeType,
                            timeFrame,
                            category: categoryData.title,
                            measurements: categoryData.measurements,
                            experimentalValue,
                            controlValue,
                            effectSize,
                            experimentalSampleSize,
                            controlSampleSize
                        });
                    }
                });
            });
        });
        
        // Add this study's info to the collection if it has outcomes
        if (studyInfo.outcomes.length > 0) {
            appState.allTrialOutcomes.push(studyInfo);
        }
    });
    
    console.log(`Collected outcome data from ${appState.allTrialOutcomes.length} studies`);
    console.log("All outcomes data:", appState.allTrialOutcomes);
    TrialDashboard.loadData(appState.allTrialOutcomes);

    console.log( "td" , appState.allTrialOutcomes)
    a =  appState.allTrialOutcomes
    TrialDashboard.loadData(a);
    
    // Now that we have all the data, create the visualizations
    // createAggregateVisualizations();
}

// Function to create all visualizations from the collected data
function createAggregateVisualizations() {
    // Skip if we don't have data
    if (appState.allTrialOutcomes.length === 0) {
        console.warn("No trial outcome data available for visualization");
        return;
    }
    
    // Extract all outcome metrics for the selector
    const outcomeMetrics = new Set();
    appState.allTrialOutcomes.forEach(study => {
        study.outcomes.forEach(outcome => {
            outcomeMetrics.add(outcome.title);
        });
    });
    
    // Update the metrics array and selector
    appState.outcomeMetrics = Array.from(outcomeMetrics);
    
    if (appState.outcomeMetrics.length > 0) {
        // Set default metric if not already set
        if (!appState.currentOutcomeMetric || !appState.outcomeMetrics.includes(appState.currentOutcomeMetric)) {
            appState.currentOutcomeMetric = appState.outcomeMetrics[0];
        }
        
        // Populate the selector
        populateOutcomeMetricSelector();
        
        // Show the collated outcomes section
        showSection(elements.collatedOutcomesSection, true);
        
        // Create the visualizations
        displayCollatedOutcomes();
    }
}

// Modified function to handle missing chart elements more gracefully
function createOverallTreatmentEffectChart(outcomes) {
    const canvasId = 'overallTreatmentEffectChart';
    const canvas = document.getElementById(canvasId);
    
    if (!canvas) {
        console.warn(`Canvas not found: ${canvasId}`);
        // Try to create the canvas if its container exists
        const container = document.querySelector('#collatedOutcomesSection .h-72');
        if (container) {
            container.innerHTML = `<canvas id="${canvasId}"></canvas>`;
            console.log(`Created canvas: ${canvasId}`);
            // Try again with the new canvas
            const newCanvas = document.getElementById(canvasId);
            if (!newCanvas) {
                console.error(`Failed to create canvas: ${canvasId}`);
                return;
            }
            createOverallTreatmentEffectChart(outcomes);
            return;
        }
        return;
    }
    
    const ctx = canvas.getContext('2d');
    
    // Clear previous chart
    if (charts.overallTreatmentEffect) {
        charts.overallTreatmentEffect.destroy();
    }
    
    // Filter only outcomes with effect sizes
    const validOutcomes = outcomes.filter(o => o.effectSize !== null);
    
    if (validOutcomes.length === 0) {
        canvas.parentElement.innerHTML = '<p class="text-center text-gray-500 py-8">No treatment effect data available for the selected metric.</p>';
        return;
    }
    
    // Calculate mean and standard deviation of effect sizes
    const effectSizes = validOutcomes.map(o => o.effectSize);
    const mean = calculateMean(effectSizes);
    const stdDev = calculateStandardDeviation(effectSizes, mean);
    
    // Generate normal distribution data
    const bellCurveData = generateNormalDistribution(mean, stdDev);
    
    // Generate scatter plot data for individual studies
    const scatterData = validOutcomes.map(o => ({
        x: o.effectSize,
        y: 0.05, // Small fixed value for visibility
        nctId: o.nctId,
        title: o.title,
        phase: o.phase
    }));
    
    // Create the chart
    charts.overallTreatmentEffect = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [
                {
                    type: 'line',
                    label: 'Overall Distribution',
                    data: bellCurveData,
                    borderColor: '#8b5cf6', // Violet
                    backgroundColor: 'rgba(139, 92, 246, 0.2)', // Transparent violet
                    fill: true,
                    tension: 0.4,
                    pointRadius: 0
                },
                {
                    type: 'scatter',
                    label: 'Individual Studies',
                    data: scatterData,
                    backgroundColor: ctx => {
                        // Color points by phase
                        const phase = scatterData[ctx.dataIndex]?.phase;
                        return getPhaseColor(phase);
                    },
                    pointRadius: 6,
                    pointHoverRadius: 8
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'linear',
                    title: {
                        display: true,
                        text: 'Effect Size'
                    },
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)'
                    }
                },
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Probability Density'
                    },
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)'
                    }
                }
            },
            plugins: {
                legend: {
                    position: 'top',
                },
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            const dataIndex = context[0].dataIndex;
                            const datasetIndex = context[0].datasetIndex;
                            
                            if (datasetIndex === 1) { // Scatter plot
                                return scatterData[dataIndex].title || 'Study';
                            }
                            return 'Effect Size Distribution';
                        },
                        label: function(context) {
                            const dataIndex = context.dataIndex;
                            const datasetIndex = context.datasetIndex;
                            
                            if (datasetIndex === 1) { // Scatter plot
                                return [
                                    `NCT ID: ${scatterData[dataIndex].nctId || 'Unknown'}`,
                                    `Phase: ${formatPhase(scatterData[dataIndex].phase)}`,
                                    `Effect Size: ${scatterData[dataIndex].x.toFixed(2)}`
                                ];
                            }
                            return `Value: ${context.parsed.x.toFixed(2)}`;
                        }
                    }
                }
            }
        }
    });
}
        function createOutcomeCharts(study) {
            const nctId = study.protocolSection?.identificationModule?.nctId;
            const outcomes = study.resultsSection?.outcomeMeasuresModule?.outcomeMeasures || [];
            const primaryOutcomes = outcomes.filter(outcome => outcome.type === "PRIMARY");
            const secondaryOutcomes = outcomes.filter(outcome => outcome.type === "SECONDARY");
            
            // Clean up any existing chart instances
            Object.keys(charts.studySpecific).forEach(chartId => {
                if (chartId.includes(nctId)) {
                    if (charts.studySpecific[chartId]) {
                        charts.studySpecific[chartId].destroy();
                        delete charts.studySpecific[chartId];
                    }
                }
            });
            
            // Create charts for primary outcomes
            primaryOutcomes.forEach((outcome, idx) => {
                createSingleOutcomeChart(nctId, outcome, idx, false);
            });
            
            // Create charts for secondary outcomes
            secondaryOutcomes.forEach((outcome, idx) => {
                createSingleOutcomeChart(nctId, outcome, idx, true);
            });
        }
        
        function createSingleOutcomeChart(nctId, outcome, idx, isSecondary) {
            const prefix = isSecondary ? 'outcome_secondary_' : 'outcome_';
            const canvasId = `${prefix}${nctId}_${idx}`;
            const canvas = document.getElementById(canvasId);
            
            if (!canvas) {
                console.warn(`Canvas not found for ${canvasId}`);
                return;
            }
            
            // Check if outcome has classes and measurements
            if (!outcome.classes || !outcome.classes[0] || !outcome.classes[0].categories) {
                console.warn(`No valid measurements for ${outcome.title}`);
                return;
            }
            
            const measurements = [];
            outcome.classes.forEach(cls => {
                cls.categories.forEach(cat => {
                    cat.measurements.forEach(measurement => {
                        if (measurement && measurement.value !== undefined && measurement.groupId) {
                            const group = outcome.groups.find(g => g.id === measurement.groupId);
                            if (group) {
                                // Use parseFloat but provide a default for empty values
                                const value = measurement.value === '' ? null : parseFloat(measurement.value);
                                let dispersion = null;
                                let dispersionType = null;
                                let spread = null;
                                
                                // Extract dispersion information if available
                                if (measurement.dispersion !== undefined && measurement.dispersion !== '') {
                                    dispersion = parseFloat(measurement.dispersion);
                                    dispersionType = measurement.dispersionType;
                                }
                                
                                // Calculate spread (standard deviation) if needed
                                if (dispersionType === 'standard_error') {
                                    const sampleSize = group.participantsAnalyzedList?.[0]?.count;
                                    if (sampleSize && !isNaN(sampleSize) && sampleSize > 0) {
                                        spread = dispersion * Math.sqrt(sampleSize);
                                    }
                                } else if (dispersionType === 'standard_deviation') {
                                    spread = dispersion;
                                } else {
                                    spread = parseFloat(measurement.spread || 0);
                                }
                                
                                measurements.push({
                                    groupId: measurement.groupId,
                                    groupTitle: group.title || 'Unknown Group',
                                    value: value,
                                    dispersion: dispersion,
                                    dispersionType: dispersionType,
                                    spread: spread,
                                    category: cat.title || 'Unknown Category',
                                    sampleSize: group.participantsAnalyzedList?.[0]?.count || 0
                                });
                            }
                        }
                    });
                });
            });
            
            if (measurements.length === 0) {
                console.warn(`No valid measurements for ${outcome.title}`);
                return;
            }
            
            // Clean up any existing chart on this canvas
            if (charts.studySpecific[canvasId]) {
                charts.studySpecific[canvasId].destroy();
            }
            
            // Create the chart
            const ctx = canvas.getContext('2d');
            
            // Determine if values are numerical or categorical
            const isNumerical = measurements.every(m => m.value !== null && !isNaN(m.value));
            
            if (isNumerical) {
                // Bell curve or bar chart for numerical data
                const datasets = [];
                const uniqueGroups = [...new Set(measurements.map(m => m.groupId))];
                
                uniqueGroups.forEach((groupId, index) => {
                    const groupMeasurements = measurements.filter(m => m.groupId === groupId);
                    if (groupMeasurements.length > 0) {
                        const groupTitle = groupMeasurements[0].groupTitle || `Group ${index + 1}`;
                        
                        // Check if we have dispersion/spread data for bell curves
                        const hasBellCurveData = groupMeasurements.some(m => m.spread > 0);
                        
                        if (hasBellCurveData) {
                            // Generate bell curve data for measurements with spread
                            groupMeasurements.forEach(m => {
                                if (m.value !== null && !isNaN(m.value) && m.spread > 0) {
                                    const mean = m.value;
                                    const stdDev = m.spread;
                                    const bellCurveData = generateNormalDistribution(mean, stdDev);
                                    
                                    datasets.push({
                                        label: `${groupTitle} - ${m.category}`,
                                        data: bellCurveData,
                                        borderColor: getRandomColor(index),
                                        backgroundColor: getRandomColor(index, 0.2),
                                        fill: true,
                                        tension: 0.4,
                                        pointRadius: 0
                                    });
                                }
                            });
                        } else {
                            // Bar chart data for means without standard deviations
                            const barData = groupMeasurements
                                .filter(m => m.value !== null && !isNaN(m.value))
                                .map(m => ({
                                    x: m.category,
                                    y: m.value
                                }));
                            
                            if (barData.length > 0) {
                                datasets.push({
                                    type: 'bar',
                                    label: groupTitle,
                                    data: barData,
                                    backgroundColor: getRandomColor(index, 0.6),
                                    borderColor: getRandomColor(index),
                                    borderWidth: 1
                                });
                            }
                        }
                    }
                });
                
                if (datasets.length > 0) {
                    // Determine chart type based on data
                    const isBarChart = datasets.some(d => d.type === 'bar');
                    
                    const chartConfig = {
                        type: isBarChart ? 'bar' : 'line',
                        data: {
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    type: isBarChart ? 'category' : 'linear',
                                    title: {
                                        display: true,
                                        text: outcome.title || 'Value'
                                    },
                                    ticks: {
                                        callback: function(value) {
                                            // For dense values, truncate or format labels
                                            if (typeof value === 'string' && value.length > 15) {
                                                return value.substring(0, 15) + '...';
                                            }
                                            return value;
                                        }
                                    }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: isBarChart ? 'Value' : 'Probability Density'
                                    },
                                    beginAtZero: true
                                }
                            },
                            plugins: {
                                tooltip: {
                                    callbacks: {
                                        title: function(context) {
                                            return context[0].dataset.label || 'Value';
                                        },
                                        label: function(context) {
                                            if (isBarChart) {
                                                return `Value: ${context.parsed.y !== undefined ? context.parsed.y.toFixed(2) : 'N/A'}`;
                                            }
                                            return `Value: ${context.parsed.x !== undefined ? context.parsed.x.toFixed(2) : 'N/A'}`;
                                        }
                                    }
                                },
                                legend: {
                                    display: true,
                                    position: 'top',
                                    labels: {
                                        // Limit legend label lengths
                                        generateLabels: function(chart) {
                                            const originalLabels = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                                            return originalLabels.map(label => {
                                                if (label.text && label.text.length > 30) {
                                                    label.text = label.text.substring(0, 30) + '...';
                                                }
                                                return label;
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    };
                    
                    try {
                        charts.studySpecific[canvasId] = new Chart(ctx, chartConfig);
                    } catch (error) {
                        console.error(`Error creating chart for ${canvasId}:`, error);
                    }
                } else {
                    // No valid datasets
                    canvas.parentElement.innerHTML = '<p class="text-center text-gray-500">Insufficient data for visualization</p>';
                }
            } else {
                // Bar chart for categorical data
                const labels = [...new Set(measurements.map(m => m.category))].filter(label => label !== undefined);
                const datasets = [];
                const groupMap = {};
                
                measurements.forEach(m => {
                    if (!groupMap[m.groupId]) {
                        groupMap[m.groupId] = {
                            label: m.groupTitle || 'Unknown Group',
                            data: Array(labels.length).fill(null),
                            backgroundColor: getRandomColor(Object.keys(groupMap).length, 0.6),
                            borderColor: getRandomColor(Object.keys(groupMap).length),
                            borderWidth: 1
                        };
                    }
                    
                    const categoryIndex = labels.indexOf(m.category);
                    if (categoryIndex !== -1 && m.value !== null) {
                        groupMap[m.groupId].data[categoryIndex] = m.value;
                    }
                });
                
                const finalDatasets = [];
                Object.values(groupMap).forEach(group => {
                    // Only add groups that have at least one non-null value
                    if (group.data.some(val => val !== null)) {
                        finalDatasets.push(group);
                    }
                });
                
                if (finalDatasets.length > 0 && labels.length > 0) {
                    const chartConfig = {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: finalDatasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    ticks: {
                                        callback: function(value, index) {
                                            // For dense values, truncate or format labels
                                            const label = labels[index];
                                            if (typeof label === 'string' && label.length > 15) {
                                                return label.substring(0, 15) + '...';
                                            }
                                            return label;
                                        }
                                    }
                                },
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: outcome.title || 'Value'
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    position: 'top',
                                    labels: {
                                        // Limit legend label lengths
                                        generateLabels: function(chart) {
                                            const originalLabels = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                                            return originalLabels.map(label => {
                                                if (label.text && label.text.length > 30) {
                                                    label.text = label.text.substring(0, 30) + '...';
                                                }
                                                return label;
                                            });
                                        }
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        title: function(context) {
                                            const index = context[0].dataIndex;
                                            return labels[index] || 'Unknown';
                                        }
                                    }
                                }
                            }
                        }
                    };
                    
                    try {
                        charts.studySpecific[canvasId] = new Chart(ctx, chartConfig);
                    } catch (error) {
                        console.error(`Error creating categorical chart for ${canvasId}:`, error);
                    }
                } else {
                    // No valid datasets or labels
                    canvas.parentElement.innerHTML = '<p class="text-center text-gray-500">Insufficient data for visualization</p>';
                }
            }
        }

        // Function to process and display aggregate outcome data
        function processAggregateOutcomes(studies) {
    // First collect all outcome data
    collectAllTrialOutcomes();
    
    // Then populate the legacy data structure for backward compatibility
    appState.allOutcomeMeasures = [];
    
    // Process studies to extract outcome measures for the original visualization
    studies.forEach(study => {
        const nctId = study.protocolSection?.identificationModule?.nctId;
        const studyDetails = appState.studyDetails[nctId];
        if (!studyDetails || !studyDetails.resultsSection?.outcomeMeasuresModule?.outcomeMeasures) return;
        
        const phase = study.protocolSection?.designModule?.phases?.[0] || 'PRE_PHASE';
        const outcomes = studyDetails.resultsSection.outcomeMeasuresModule.outcomeMeasures;
        
        outcomes.forEach(outcome => {
            if (outcome.type !== "PRIMARY") return;
            
            if (!outcome.classes || !outcome.classes[0]?.categories) return;
            
            outcome.classes.forEach(cls => {
                cls.categories.forEach(cat => {
                    cat.measurements.forEach(measurement => {
                        const value = parseFloat(measurement.value);
                        const spread = parseFloat(measurement.spread || 0);
                        
                        if (!isNaN(value)) {
                            const group = outcome.groups.find(g => g.id === measurement.groupId);
                            const isExperimental = group?.title.toLowerCase().includes('experimental') || 
                                                 group?.title.toLowerCase().includes('treatment') ||
                                                 group?.title.toLowerCase().includes('intervention');
                            
                            // Skip placebo/control groups for aggregate analysis
                            if (!isExperimental) return;
                            
                            appState.allOutcomeMeasures.push({
                                nctId: nctId,
                                phase: phase,
                                outcomeTitle: outcome.title || 'Unknown Outcome',
                                groupTitle: group?.title || 'Unknown Group',
                                value: value,
                                spread: spread,
                                lowerIsBetter: outcome.title?.toLowerCase().includes('score') || 
                                              outcome.title?.toLowerCase().includes('scale')
                            });
                        }
                    });
                });
            });
        });
    });
    
    // Display drug success rates visualization
    displayDrugSuccessRates();
}

// Update the displayCollatedOutcomes function to first create the charts if needed
function displayCollatedOutcomes() {
    console.log("Displaying collated outcomes...");
    
    // Check if the chart canvases exist, if not create them
    ['overallTreatmentEffectChart', 'phaseComparisonChart', 'phasePerformanceChart'].forEach(canvasId => {
        if (!document.getElementById(canvasId)) {
            console.log(`Canvas ${canvasId} not found, attempting to create`);
            let container;
            switch (canvasId) {
                case 'overallTreatmentEffectChart':
                    container = document.querySelector('#collatedOutcomesSection .h-72:nth-of-type(1)');
                    break;
                case 'phaseComparisonChart':
                    container = document.querySelector('#collatedOutcomesSection .h-72:nth-of-type(2)');
                    break;
                case 'phasePerformanceChart':
                    container = document.querySelector('#collatedOutcomesSection .h-72:nth-of-type(3)');
                    break;
            }
            
            if (container) {
                container.innerHTML = `<canvas id="${canvasId}"></canvas>`;
                console.log(`Created canvas: ${canvasId}`);
            }
        }
    });
    
    // Only show if we have data
    if (appState.allTrialOutcomes.length === 0 && appState.collatedOutcomes.length === 0) {
        showSection(elements.collatedOutcomesSection, false);
        return;
    }
    
    showSection(elements.collatedOutcomesSection, true);
    
    // Get the current metric and type selection
    const currentMetric = appState.currentOutcomeMetric;
    const currentType = appState.currentOutcomeType;
    
    console.log(`Filtering outcomes by metric: ${currentMetric}, type: ${currentType}`);
    
    // First try to use the collatedOutcomes array which might already have processed data
    let filteredOutcomes = [];
    
    if (appState.collatedOutcomes.length > 0) {
        filteredOutcomes = appState.collatedOutcomes;
    } else {
        // Otherwise, compile outcomes from the allTrialOutcomes array
        appState.allTrialOutcomes.forEach(study => {
            study.outcomes.forEach(outcome => {
                if (outcome.effectSize !== null) {
                    filteredOutcomes.push({
                        nctId: study.nctId,
                        title: study.title,
                        phase: study.phase,
                        outcomeTitle: outcome.title,
                        outcomeType: outcome.type,
                        category: outcome.category,
                        experimentalValue: outcome.experimentalValue,
                        controlValue: outcome.controlValue,
                        effectSize: outcome.effectSize,
                        experimentalSampleSize: outcome.experimentalSampleSize,
                        controlSampleSize: outcome.controlSampleSize,
                        timeFrame: outcome.timeFrame
                    });
                }
            });
        });
    }
    
    // Apply filters
    if (currentMetric) {
        filteredOutcomes = filteredOutcomes.filter(outcome => 
            outcome.outcomeTitle === currentMetric
        );
    }
    
    if (currentType !== 'all') {
        filteredOutcomes = filteredOutcomes.filter(outcome => 
            outcome.outcomeType === currentType
        );
    }
    
    console.log(`Filtered to ${filteredOutcomes.length} outcomes for visualization`);
    
    // Create the charts
    createOverallTreatmentEffectChart(filteredOutcomes);
    createEnhancedPhaseComparisonChart(filteredOutcomes);
    createPhasePerformanceChart(filteredOutcomes);
    createStatisticalSummaryTable(filteredOutcomes);
}


        function displayAggregateVisualizations() {
            if (appState.allOutcomeMeasures.length === 0) {
                elements.aggregateOutcomesSection.innerHTML = `
                    <div class="bg-white rounded-lg shadow-md p-6 text-center">
                        <p class="text-gray-500">No outcome measures with results available for the selected studies.</p>
                    </div>
                `;
                return;
            }
            
            showSection(elements.aggregateOutcomesSection, true);
            
            // Create overall distribution chart
            createOverallDistributionChart();
            
            // Create phase-specific charts
            createPhaseSpecificCharts();
            
            // Display outcome measures list
            displayOutcomeMeasuresList();
        }

        function createOverallDistributionChart() {
            const canvas = document.getElementById('overallDistributionChart');
            if (!canvas) {
                console.warn("Overall distribution chart canvas not found");
                return;
            }
            
            const ctx = canvas.getContext('2d');
            
            // Clear previous chart instance if it exists
            if (charts.overallDistribution) {
                charts.overallDistribution.destroy();
            }
            
            // Standardize values (convert to z-scores)
            const outcomes = appState.allOutcomeMeasures;
            
            // Calculate mean and std dev across all measures
            const validOutcomes = outcomes.filter(o => !isNaN(o.value) && !isNaN(o.spread) && o.spread > 0);
            
            if (validOutcomes.length === 0) return;
            
            const values = validOutcomes.map(o => o.value);
            const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
            const stdDev = Math.sqrt(
                values.map(v => Math.pow(v - mean, 2)).reduce((sum, val) => sum + val, 0) / values.length
            );
            
            // Generate normal distribution data
            const bellCurveData = generateNormalDistribution(mean, stdDev);
            
            // Create chart
            charts.overallDistribution = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Overall Distribution',
                        data: bellCurveData,
                        borderColor: '#8b5cf6', // Violet
                        backgroundColor: 'rgba(139, 92, 246, 0.2)', // Transparent violet
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Standardized Outcome Value'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Probability Density'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return 'Overall Distribution';
                                },
                                label: function(context) {
                                    return `Value: ${context.parsed.x.toFixed(2)}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function createPhaseSpecificCharts() {
            const earlyPhasesCanvas = document.getElementById('earlyPhasesChart');
            const latePhasesCanvas = document.getElementById('latePhasesChart');
            
            if (!earlyPhasesCanvas || !latePhasesCanvas) {
                console.warn("Phase-specific chart canvases not found");
                return;
            }
            
            const earlyPhasesCtx = earlyPhasesCanvas.getContext('2d');
            const latePhasesCtx = latePhasesCanvas.getContext('2d');
            
            // Clear previous chart instances if they exist
            if (charts.earlyPhases) {
                charts.earlyPhases.destroy();
            }
            if (charts.latePhases) {
                charts.latePhases.destroy();
            }
            
            // Group outcomes by phase
            const outcomes = appState.allOutcomeMeasures;
            const earlyPhaseOutcomes = outcomes.filter(o => 
                o.phase === 'PHASE1' || o.phase === 'PHASE2' || o.phase === 'PHASE1_PHASE2' || o.phase === 'PRE_PHASE'
            );
            const latePhaseOutcomes = outcomes.filter(o => 
                o.phase === 'PHASE3' || o.phase === 'PHASE4'
            );
            
            // Process early phase data
            if (earlyPhaseOutcomes.length > 0) {
                // Group by specific phase
                const phase1Data = earlyPhaseOutcomes.filter(o => o.phase === 'PHASE1');
                const phase2Data = earlyPhaseOutcomes.filter(o => o.phase === 'PHASE2');
                const phase12Data = earlyPhaseOutcomes.filter(o => o.phase === 'PHASE1_PHASE2');
                const prePhaseData = earlyPhaseOutcomes.filter(o => o.phase === 'PRE_PHASE');
                
                const datasets = [];
                
                if (phase1Data.length > 0) {
                    datasets.push(createPhaseDataset(phase1Data, 'Phase 1', '#60a5fa'));
                }
                if (phase2Data.length > 0) {
                    datasets.push(createPhaseDataset(phase2Data, 'Phase 2', '#34d399'));
                }
                if (phase12Data.length > 0) {
                    datasets.push(createPhaseDataset(phase12Data, 'Phase 1/2', '#38bdf8'));
                }
                if (prePhaseData.length > 0) {
                    datasets.push(createPhaseDataset(prePhaseData, 'Pre-Phase', '#9ca3af'));
                }
                
                // Create chart
                charts.earlyPhases = new Chart(earlyPhasesCtx, {
                    type: 'line',
                    data: {
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        scales: {
                            x: {
                                type: 'linear',
                                title: {
                                    display: true,
                                    text: 'Standardized Outcome Value'
                                }
                            },
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Probability Density'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'top',
                            }
                        }
                    }
                });
            }
            
            // Process late phase data
            if (latePhaseOutcomes.length > 0) {
                // Group by specific phase
                const phase3Data = latePhaseOutcomes.filter(o => o.phase === 'PHASE3');
                const phase4Data = latePhaseOutcomes.filter(o => o.phase === 'PHASE4');
                
                const datasets = [];
                
                if (phase3Data.length > 0) {
                    datasets.push(createPhaseDataset(phase3Data, 'Phase 3', '#a78bfa'));
                }
                if (phase4Data.length > 0) {
                    datasets.push(createPhaseDataset(phase4Data, 'Phase 4', '#f97316'));
                }
                
                // Create chart
                charts.latePhases = new Chart(latePhasesCtx, {
                    type: 'line',
                    data: {
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        scales: {
                            x: {
                                type: 'linear',
                                title: {
                                    display: true,
                                    text: 'Standardized Outcome Value'
                                }
                            },
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Probability Density'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'top',
                            }
                        }
                    }
                });
            }
        }

        function createPhaseDataset(phaseData, label, color) {
            const validData = phaseData.filter(o => !isNaN(o.value) && !isNaN(o.spread) && o.spread > 0);
            
            if (validData.length === 0) {
                return {
                    label: label,
                    data: [],
                    borderColor: color,
                    backgroundColor: hexToRgba(color, 0.2),
                    fill: true,
                    tension: 0.4,
                    pointRadius: 0
                };
            }
            
            const values = validData.map(o => o.value);
            const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
            const stdDev = Math.sqrt(
                values.map(v => Math.pow(v - mean, 2)).reduce((sum, val) => sum + val, 0) / values.length
            ) || 1; // Default to 1 if stdDev is 0 to avoid division by zero
            
            // Generate normal distribution data
            const bellCurveData = generateNormalDistribution(mean, stdDev);
            
            return {
                label: label,
                data: bellCurveData,
                borderColor: color,
                backgroundColor: hexToRgba(color, 0.2),
                fill: true,
                tension: 0.4,
                pointRadius: 0
            };
        }

        function displayOutcomeMeasuresList() {
            const outcomeMeasuresList = document.getElementById('outcomeMeasuresList');
            if (!outcomeMeasuresList) {
                console.warn("Outcome measures list element not found");
                return;
            }
            
            outcomeMeasuresList.innerHTML = '';
            
            // Group outcomes by measure title
            const outcomes = appState.allOutcomeMeasures;
            const outcomesByTitle = {};
            
            outcomes.forEach(outcome => {
                const title = outcome.outcomeTitle || 'Unknown Outcome';
                if (!outcomesByTitle[title]) {
                    outcomesByTitle[title] = [];
                }
                outcomesByTitle[title].push(outcome);
            });
            
            // Sort outcome titles by frequency (most common first)
            const sortedTitles = Object.keys(outcomesByTitle).sort((a, b) => 
                outcomesByTitle[b].length - outcomesByTitle[a].length
            );
            
            if (sortedTitles.length === 0) {
                outcomeMeasuresList.innerHTML = '<p class="text-center text-gray-500">No outcome measures available</p>';
                return;
            }
            
            sortedTitles.forEach(title => {
                const outcomesByPhase = {};
                
                // Group by phase
                outcomesByTitle[title].forEach(outcome => {
                    const phase = outcome.phase;
                    if (!outcomesByPhase[phase]) {
                        outcomesByPhase[phase] = [];
                    }
                    outcomesByPhase[phase].push(outcome);
                });
                
                // Create outcome card
                const card = document.createElement('div');
                card.className = 'bg-white p-4 rounded-lg border border-gray-200';
                
                // Calculate average value across all phases
                const allValues = outcomesByTitle[title].map(o => o.value);
                const avgValue = allValues.reduce((sum, val) => sum + val, 0) / allValues.length;
                
                // Construct phase data HTML
                const phaseDataHtml = Object.keys(outcomesByPhase)
                    .map(phase => {
                        const phaseOutcomes = outcomesByPhase[phase];
                        const phaseValues = phaseOutcomes.map(o => o.value);
                        const avgPhaseValue = phaseValues.reduce((sum, val) => sum + val, 0) / phaseValues.length;
                        
                        return `
                            <div class="flex items-center mb-1">
                                <span class="inline-block w-3 h-3 rounded-full mr-2" style="background-color: ${getPhaseColor(phase)}"></span>
                                <span class="text-sm">${formatPhase(phase)}: ${avgPhaseValue.toFixed(2)}</span>
                            </div>
                        `;
                    })
                    .join('');
                
                card.innerHTML = `
                    <h4 class="text-md font-medium mb-2">${title}</h4>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <p class="text-sm text-gray-600 mb-2">Studies: ${outcomesByTitle[title].length}</p>
                            <p class="text-sm text-gray-600 mb-2">Average value: ${avgValue.toFixed(2)}</p>
                            <div class="mt-2">
                                ${phaseDataHtml}
                            </div>
                        </div>
                        <div>
                            <div class="h-32">
                                <canvas id="outcome_summary_${title.replace(/\s+/g, '_').substring(0, 30)}"></canvas>
                            </div>
                        </div>
                    </div>
                `;
                
                outcomeMeasuresList.appendChild(card);
                
                // Create summary chart
                const canvasId = `outcome_summary_${title.replace(/\s+/g, '_').substring(0, 30)}`;
                const canvas = document.getElementById(canvasId);
                
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    const datasets = [];
                    
                    Object.keys(outcomesByPhase).forEach((phase, index) => {
                        const phaseOutcomes = outcomesByPhase[phase];
                        const phaseValues = phaseOutcomes.map(o => o.value);
                        const avgPhaseValue = phaseValues.reduce((sum, val) => sum + val, 0) / phaseValues.length;
                        
                        datasets.push({
                            label: formatPhase(phase),
                            data: [{x: formatPhase(phase), y: avgPhaseValue}],
                            backgroundColor: getPhaseColor(phase),
                            borderColor: getPhaseColor(phase),
                            borderWidth: 1
                        });
                    });
                    
                    new Chart(ctx, {
                        type: 'bar',
                        data: {
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            indexAxis: 'y',
                            scales: {
                                x: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Average Value'
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    display: false
                                }
                            }
                        }
                    });
                }
            });
        }

        // New function to display collated outcomes
        function displayCollatedOutcomes() {
    // Only show if we have data
    if (appState.collatedOutcomes.length === 0) {
        showSection(elements.collatedOutcomesSection, false);
        return;
    }
    
    showSection(elements.collatedOutcomesSection, true);
    
    // Get the current metric and type selection
    const currentMetric = appState.currentOutcomeMetric;
    const currentType = appState.currentOutcomeType;
    
    // Filter outcomes by metric and type
    let filteredOutcomes = appState.collatedOutcomes;
    
    if (currentMetric) {
        filteredOutcomes = filteredOutcomes.filter(outcome => 
            outcome.outcomeTitle === currentMetric
        );
    }
    
    if (currentType !== 'all') {
        filteredOutcomes = filteredOutcomes.filter(outcome => 
            outcome.outcomeType === currentType
        );
    }
    
    // Create the overall treatment effect chart
    createOverallTreatmentEffectChart(filteredOutcomes);
    
    // Create the enhanced phase comparison chart
    createEnhancedPhaseComparisonChart(filteredOutcomes);
    
    // Create the new phase performance chart
    createPhasePerformanceChart(filteredOutcomes);
    
    // Create the statistical summary table
    createStatisticalSummaryTable(filteredOutcomes);
}

        function createOverallTreatmentEffectChart(outcomes) {
            const canvas = document.getElementById('overallTreatmentEffectChart');
            if (!canvas) {
                console.warn("Overall treatment effect chart canvas not found");
                return;
            }
            
            const ctx = canvas.getContext('2d');
            
            // Clear previous chart
            if (charts.overallTreatmentEffect) {
                charts.overallTreatmentEffect.destroy();
            }
            
            // Filter only outcomes with effect sizes
            const validOutcomes = outcomes.filter(o => o.effectSize !== null);
            
            if (validOutcomes.length === 0) {
                canvas.parentElement.innerHTML = '<p class="text-center text-gray-500 py-8">No treatment effect data available for the selected metric.</p>';
                return;
            }
            
            // Calculate mean and standard deviation of effect sizes
            const effectSizes = validOutcomes.map(o => o.effectSize);
            const mean = calculateMean(effectSizes);
            const stdDev = calculateStandardDeviation(effectSizes, mean);
            
            // Generate normal distribution data
            const bellCurveData = generateNormalDistribution(mean, stdDev);
            
            // Generate scatter plot data for individual studies
            const scatterData = validOutcomes.map(o => ({
                x: o.effectSize,
                y: 0.05, // Small fixed value for visibility
                nctId: o.nctId,
                title: o.title,
                phase: o.phase
            }));
            
            // Create the chart
            charts.overallTreatmentEffect = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            type: 'line',
                            label: 'Overall Distribution',
                            data: bellCurveData,
                            borderColor: '#8b5cf6', // Violet
                            backgroundColor: 'rgba(139, 92, 246, 0.2)', // Transparent violet
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0
                        },
                        {
                            type: 'scatter',
                            label: 'Individual Studies',
                            data: scatterData,
                            backgroundColor: ctx => {
                                // Color points by phase
                                const phase = scatterData[ctx.dataIndex]?.phase;
                                return getPhaseColor(phase);
                            },
                            pointRadius: 6,
                            pointHoverRadius: 8
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Effect Size'
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Probability Density'
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const dataIndex = context[0].dataIndex;
                                    const datasetIndex = context[0].datasetIndex;
                                    
                                    if (datasetIndex === 1) { // Scatter plot
                                        return scatterData[dataIndex].title || 'Study';
                                    }
                                    return 'Effect Size Distribution';
                                },
                                label: function(context) {
                                    const dataIndex = context.dataIndex;
                                    const datasetIndex = context.datasetIndex;
                                    
                                    if (datasetIndex === 1) { // Scatter plot
                                        return [
                                            `NCT ID: ${scatterData[dataIndex].nctId || 'Unknown'}`,
                                            `Phase: ${formatPhase(scatterData[dataIndex].phase)}`,
                                            `Effect Size: ${scatterData[dataIndex].x.toFixed(2)}`
                                        ];
                                    }
                                    return `Value: ${context.parsed.x.toFixed(2)}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function createEnhancedPhaseComparisonChart(outcomes) {
    const canvasId = 'phaseComparisonChart';
    const canvas = document.getElementById(canvasId);
    
    if (!canvas) {
        console.warn(`Canvas not found: ${canvasId}`);
        // Try to create the canvas if its container exists
        const container = document.querySelector('#collatedOutcomesSection .h-72:nth-of-type(2)');
        if (container) {
            container.innerHTML = `<canvas id="${canvasId}"></canvas>`;
            console.log(`Created canvas: ${canvasId}`);
            // Try again with the new canvas
            const newCanvas = document.getElementById(canvasId);
            if (!newCanvas) {
                console.error(`Failed to create canvas: ${canvasId}`);
                return;
            }
            createEnhancedPhaseComparisonChart(outcomes);
            return;
        }
        return;
    }
    
    // Rest of the function implementation...
    const ctx = canvas.getContext('2d');
    
    // Clear previous chart
    if (charts.phaseComparison) {
        charts.phaseComparison.destroy();
    }
    
    // Filter only outcomes with effect sizes
    const validOutcomes = outcomes.filter(o => o.effectSize !== null);
    
    if (validOutcomes.length === 0) {
        canvas.parentElement.innerHTML = '<p class="text-center text-gray-500 py-8">No phase-specific data available for the selected metric.</p>';
        return;
    }
    
    // Group outcomes by phase
    const phaseGroups = {};
    const phaseOrder = { 
        "PRE_PHASE": 0, 
        "PHASE1": 1, 
        "PHASE1_PHASE2": 1.5,
        "PHASE2": 2, 
        "PHASE3": 3, 
        "PHASE4": 4,
        "N/A": 5
    };
    
    validOutcomes.forEach(o => {
        const phase = o.phase || 'N/A';
        if (!phaseGroups[phase]) {
            phaseGroups[phase] = [];
        }
        phaseGroups[phase].push(o.effectSize);
    });
    
    // Calculate phase statistics and prepare datasets
    const phases = Object.keys(phaseGroups)
        .filter(phase => phaseGroups[phase].length >= 2) // Only include phases with enough data
        .sort((a, b) => phaseOrder[a] - phaseOrder[b]);
    
    if (phases.length === 0) {
        canvas.parentElement.innerHTML = '<p class="text-center text-gray-500 py-8">Insufficient data for phase comparison visualization.</p>';
        return;
    }
    
    const datasets = [];
    const allEffectSizes = validOutcomes.map(o => o.effectSize);
    
    // Find global min and max for consistent scaling
    const globalMin = Math.min(...allEffectSizes);
    const globalMax = Math.max(...allEffectSizes);
    const range = globalMax - globalMin;
    const paddedMin = globalMin - (range * 0.1);
    const paddedMax = globalMax + (range * 0.1);
    
    phases.forEach((phase) => {
        const effectSizes = phaseGroups[phase];
        const mean = calculateMean(effectSizes);
        const stdDev = calculateStandardDeviation(effectSizes, mean) || 1; // Default to 1 if stdDev is 0
        
        // Generate normal distribution data with consistent x-scale
        const points = 100;
        const step = (paddedMax - paddedMin) / points;
        const bellCurveData = [];
        
        for (let x = paddedMin; x <= paddedMax; x += step) {
            const y = (1 / (stdDev * Math.sqrt(2 * Math.PI))) * 
                      Math.exp(-Math.pow(x - mean, 2) / (2 * Math.pow(stdDev, 2)));
            bellCurveData.push({ x, y });
        }
        
        datasets.push({
            label: formatPhase(phase),
            data: bellCurveData,
            borderColor: getPhaseColor(phase),
            backgroundColor: hexToRgba(getPhaseColor(phase), 0.1),
            borderWidth: 2,
            fill: true,
            tension: 0.4,
            pointRadius: 0
        });
    });
    
    // Create the chart with proper scaling
    charts.phaseComparison = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'linear',
                    title: {
                        display: true,
                        text: 'Effect Size'
                    },
                    min: paddedMin,
                    max: paddedMax,
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)'
                    }
                },
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Probability Density'
                    },
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)'
                    }
                }
            },
            plugins: {
                legend: {
                    position: 'top',
                },
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            return context[0].dataset.label;
                        },
                        label: function(context) {
                            const phaseLabel = context.dataset.label;
                            const effectSize = context.parsed.x.toFixed(2);
                            
                            // Get the phase from the label
                            const phase = Object.keys(phaseOrder).find(p => 
                                formatPhase(p) === phaseLabel
                            );
                            
                            if (phase) {
                                const effectSizes = phaseGroups[phase];
                                const mean = calculateMean(effectSizes);
                                const count = effectSizes.length;
                                
                                return [
                                    `Effect Size: ${effectSize}`,
                                    `Mean Effect: ${mean.toFixed(2)}`,
                                    `Studies: ${count}`
                                ];
                            }
                            
                            return `Effect Size: ${effectSize}`;
                        }
                    }
                }
            }
        }
    });
}

// And for the phase performance chart
function createPhasePerformanceChart(outcomes) {
    const canvasId = 'phasePerformanceChart';
    const canvas = document.getElementById(canvasId);
    
    if (!canvas) {
        console.warn(`Canvas not found: ${canvasId}`);
        // Try to create the canvas if its container exists
        const container = document.querySelector('#collatedOutcomesSection .h-72:nth-of-type(3)');
        if (container) {
            container.innerHTML = `<canvas id="${canvasId}"></canvas>`;
            console.log(`Created canvas: ${canvasId}`);
            // Try again with the new canvas
            const newCanvas = document.getElementById(canvasId);
            if (!newCanvas) {
                console.error(`Failed to create canvas: ${canvasId}`);
                return;
            }
            createPhasePerformanceChart(outcomes);
            return;
        }
        return;
    }
    
    // Rest of the function implementation...
    const ctx = canvas.getContext('2d');
    
    // Clear previous chart
    if (charts.phasePerformance) {
        charts.phasePerformance.destroy();
    }
    
    // Filter only outcomes with effect sizes
    const validOutcomes = outcomes.filter(o => o.effectSize !== null);
    
    if (validOutcomes.length === 0) {
        canvas.parentElement.innerHTML = '<p class="text-center text-gray-500 py-8">No phase-specific data available for the selected metric.</p>';
        return;
    }
    
    // Group outcomes by phase
    const phaseGroups = {};
    const phaseOrder = { 
        "PRE_PHASE": 0, 
        "PHASE1": 1, 
        "PHASE1_PHASE2": 1.5,
        "PHASE2": 2, 
        "PHASE3": 3, 
        "PHASE4": 4,
        "N/A": 5
    };
    
    validOutcomes.forEach(o => {
        const phase = o.phase || 'N/A';
        if (!phaseGroups[phase]) {
            phaseGroups[phase] = [];
        }
        phaseGroups[phase].push(o.effectSize);
    });
    
    // Calculate phase statistics for the bar chart
    const phases = Object.keys(phaseGroups)
        .filter(phase => phaseGroups[phase].length >= 2) // Only include phases with enough data
        .sort((a, b) => phaseOrder[a] - phaseOrder[b]);
    
    if (phases.length === 0) {
        canvas.parentElement.innerHTML = '<p class="text-center text-gray-500 py-8">Insufficient data for phase performance visualization.</p>';
        return;
    }
    
    const labels = phases.map(phase => formatPhase(phase));
    const meanValues = [];
    const errorBars = {
        plus: [],
        minus: []
    };
    
    phases.forEach(phase => {
        const effectSizes = phaseGroups[phase];
        const mean = calculateMean(effectSizes);
        const stdDev = calculateStandardDeviation(effectSizes, mean);
        const n = effectSizes.length;
        const ci = calculateConfidenceInterval(mean, stdDev, n);
        
        meanValues.push(mean);
        errorBars.plus.push(ci.upper - mean);
        errorBars.minus.push(mean - ci.lower);
    });
    
    // Create the chart
    charts.phasePerformance = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Mean Effect Size',
                data: meanValues,
                backgroundColor: phases.map(phase => hexToRgba(getPhaseColor(phase), 0.7)),
                borderColor: phases.map(phase => getPhaseColor(phase)),
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    title: {
                        display: true,
                        text: 'Effect Size'
                    },
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)'
                    }
                },
                x: {
                    title: {
                        display: true,
                        text: 'Trial Phase'
                    },
                    grid: {
                        display: false
                    }
                }
            },
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            return context[0].label;
                        },
                        label: function(context) {
                            const index = context.dataIndex;
                            const phase = phases[index];
                            const effectSizes = phaseGroups[phase];
                            const mean = meanValues[index];
                            const stdDev = calculateStandardDeviation(effectSizes);
                            const n = effectSizes.length;
                            const ci = calculateConfidenceInterval(mean, stdDev, n);
                            
                            return [
                                `Mean Effect: ${mean.toFixed(2)}`,
                                `95% CI: [${ci.lower.toFixed(2)}, ${ci.upper.toFixed(2)}]`,
                                `Studies: ${n}`
                            ];
                        }
                    }
                }
            }
        },
        plugins: [{
            id: 'errorBars',
            afterDatasetsDraw: function(chart) {
                const ctx = chart.ctx;
                
                chart.data.datasets.forEach((dataset, i) => {
                    const meta = chart.getDatasetMeta(i);
                    
                    if (!meta.hidden) {
                        meta.data.forEach((element, index) => {
                            // Draw error bars
                            const plus = errorBars.plus[index];
                            const minus = errorBars.minus[index];
                            const x = element.x;
                            const y = element.y;
                            
                            const barWidth = 3;
                            
                            // Save state
                            ctx.save();
                            
                            // Line style
                            ctx.lineWidth = 2;
                            ctx.strokeStyle = dataset.borderColor[index] || dataset.borderColor;
                            
                            // Draw the line
                            ctx.beginPath();
                            ctx.moveTo(x, y - plus);
                            ctx.lineTo(x, y + minus);
                            ctx.stroke();
                            
                            // Draw the top cap
                            ctx.beginPath();
                            ctx.moveTo(x - barWidth, y - plus);
                            ctx.lineTo(x + barWidth, y - plus);
                            ctx.stroke();
                            
                            // Draw the bottom cap
                            ctx.beginPath();
                            ctx.moveTo(x - barWidth, y + minus);
                            ctx.lineTo(x + barWidth, y + minus);
                            ctx.stroke();
                            
                            // Restore state
                            ctx.restore();
                        });
                    }
                });
            }
        }]
    });
}

    
// Function to initialize FDA data section
// Function to initialize FDA data section
function initFdaDataSection() {
  // Show the section
  showSection(elements.fdaDataSection, true);
  
  // Initialize counters
  elements.fdaDocCount.textContent = "0 documents";
  elements.orangeBookCount.textContent = "0 entries";
  elements.dailyMedCount.textContent = "0 entries";
  elements.warningLettersCount.textContent = "0 letters";
}

// Function to display FDA data when available
async function displayFdaData(drugName) {
  // Initialize the FDA data section
  initFdaDataSection();
  
  // Show loading state
  const loadingTemplate = `
    <div class="flex justify-center items-center py-8">
      <svg class="animate-spin h-8 w-8 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
      <span class="ml-2 text-gray-600">Loading FDA data...</span>
    </div>
  `;
  
  elements.fdaDocuments.innerHTML = loadingTemplate;
  elements.orangeBookData.innerHTML = loadingTemplate;
  elements.dailyMedData.innerHTML = loadingTemplate;
  
  try {
    // Fetch FDA drug data
    const fdaResponse = await fetch(`/api/fda/drug/${encodeURIComponent(drugName)}`);
    const fdaData = await fdaResponse.json();
    
    if (fdaResponse.ok && !fdaData.error) {
      await displayFdaSubmissions(fdaData, drugName);
    } else {
      elements.fdaDocuments.innerHTML = createErrorMessage("Could not retrieve FDA submissions data");
    }
    
    // Fetch Orange Book data
    const orangeBookResponse = await fetch(`/api/fda/orangebook/search?q=${encodeURIComponent(drugName)}`);
    const orangeBookData = await orangeBookResponse.json();
    
    if (orangeBookResponse.ok && !orangeBookData.error) {
      displayOrangeBookData(orangeBookData);
    } else {
      elements.orangeBookData.innerHTML = createErrorMessage("Could not retrieve Orange Book data");
    }
    
    // Fetch DailyMed data
    const dailyMedResponse = await fetch(`/api/fda/dailymed/${encodeURIComponent(drugName)}`);
    const dailyMedData = await dailyMedResponse.json();
    
    if (dailyMedResponse.ok && !dailyMedData.error) {
      displayDailyMedData(dailyMedData);
    } else {
      elements.dailyMedData.innerHTML = createErrorMessage("Could not retrieve DailyMed data");
    }
    
  } catch (error) {
    console.error("Error fetching FDA data:", error);
    elements.fdaDocuments.innerHTML = createErrorMessage("Error fetching FDA data");
    elements.orangeBookData.innerHTML = createErrorMessage("Error fetching FDA data");
    elements.dailyMedData.innerHTML = createErrorMessage("Error fetching FDA data");
  }
}

// Helper function to create error messages
function createErrorMessage(message) {
  return `
    <div class="flex justify-center items-center py-8 text-red-500">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
      </svg>
      <span>${message}</span>
    </div>
  `;
}

// Function to display FDA submissions
async function displayFdaSubmissions(fdaData, drugName) {
  // Check if FDA data is empty
  if (Object.keys(fdaData).length === 0) {
    elements.fdaDocuments.innerHTML = `
      <div class="text-center p-4">
        <p class="text-sm text-gray-700">No FDA submissions found for "${drugName}"</p>
      </div>
    `;
    elements.fdaDocCount.textContent = "0 documents";
    return;
  }
  
  // Collect all products into a flat array for easier pagination
  let allProducts = [];
  Object.entries(fdaData).forEach(([brandName, strengths]) => {
    Object.entries(strengths).forEach(([strength, products]) => {
      products.forEach(product => {
        allProducts.push({
          ...product,
          strength
        });
      });
    });
  });
  
  // Count total entries for the counter
  const totalEntries = allProducts.length;
  
  // Update the counter
  elements.fdaDocCount.textContent = `${totalEntries} submissions`;
  
  // Pagination settings
  const itemsPerPage = 10;
  const totalPages = Math.ceil(totalEntries / itemsPerPage);
  let currentPage = 1;
  
  // Function to render products for the current page
  function renderCurrentPage() {
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = Math.min(startIndex + itemsPerPage, totalEntries);
    const productsToShow = allProducts.slice(startIndex, endIndex);
    
    // Create HTML for FDA submissions
    let html = `<div class="grid grid-cols-1 md:grid-cols-3 gap-4">`;
    
    // Iterate through each product for the current page
    for (const product of productsToShow) {
      // Create a card for each product
      html += `
        <div class="bg-white border border-gray-200 rounded-md shadow-sm hover:shadow-md transition-shadow">
          <div class="p-3">
            <div class="flex justify-between items-start">
              <div class="truncate pr-2">
                <h4 class="text-sm font-semibold truncate">${product.brandName}</h4>
                <p class="text-xs text-gray-600">${product.strength}</p>
              </div>
              <span class="px-2 py-1 text-xs bg-blue-100 text-blue-800 rounded-full whitespace-nowrap">
                ${product.applicationNumber}
              </span>
            </div>
            
            <div class="mt-2 text-xs">
              <p><span class="font-medium">Approved:</span> ${product.approvalDate}</p>
              <p class="truncate"><span class="font-medium">Manufacturer:</span> ${product.manufacturerName || product.sponsorName}</p>
              <p class="truncate"><span class="font-medium">Form:</span> ${product.dosageForm}</p>
            </div>
            
            <div class="mt-2 flex justify-end">
              <button
                class="px-2 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-700 transition-colors view-details-btn"
                data-application="${product.applicationNumber}"
                data-brand="${product.brandName}"
                data-ingredient="${product.activeIngredients?.[0]?.name || drugName}"
              >
                Details
              </button>
            </div>
          </div>
        </div>
      `;
    }
    
    html += `</div>`;
    
    // Add pagination controls
    if (totalPages > 1) {
      html += `
        <div class="mt-6 flex justify-center">
          <nav class="flex items-center">
            <button id="prev-page" class="px-3 py-1 border border-gray-300 rounded-l ${currentPage === 1 ? 'bg-gray-100 cursor-not-allowed text-gray-400' : 'bg-white hover:bg-gray-50 text-gray-700'}" ${currentPage === 1 ? 'disabled' : ''}>
              Previous
            </button>
            
            <div class="px-4 py-1 border-t border-b border-gray-300 bg-white text-sm">
              Page ${currentPage} of ${totalPages}
            </div>
            
            <button id="next-page" class="px-3 py-1 border border-gray-300 rounded-r ${currentPage === totalPages ? 'bg-gray-100 cursor-not-allowed text-gray-400' : 'bg-white hover:bg-gray-50 text-gray-700'}" ${currentPage === totalPages ? 'disabled' : ''}>
              Next
            </button>
          </nav>
        </div>
      `;
    }
    
    elements.fdaDocuments.innerHTML = html;
    
    // Add event listeners to the "View Details" buttons
    document.querySelectorAll('.view-details-btn').forEach(button => {
      button.addEventListener('click', function() {
        const applicationNumber = this.getAttribute('data-application');
        const brandName = this.getAttribute('data-brand');
        const ingredient = this.getAttribute('data-ingredient');
        openDetailsModal(applicationNumber, brandName, ingredient);
      });
    });
    
    // Add event listeners to pagination buttons
    if (totalPages > 1) {
      document.getElementById('prev-page')?.addEventListener('click', function() {
        if (currentPage > 1) {
          currentPage--;
          renderCurrentPage();
          // Scroll to top of results
          elements.fdaDocuments.scrollIntoView({ behavior: 'smooth' });
        }
      });
      
      document.getElementById('next-page')?.addEventListener('click', function() {
        if (currentPage < totalPages) {
          currentPage++;
          renderCurrentPage();
          // Scroll to top of results
          elements.fdaDocuments.scrollIntoView({ behavior: 'smooth' });
        }
      });
    }
  }
  
  // Initial render
  renderCurrentPage();
}
// Function to display Orange Book data
function displayOrangeBookData(data) {
  // Count total entries
  const totalProducts = data.total.products || 0;
  
  // Update counter
  elements.orangeBookCount.textContent = `${totalProducts} entries`;
  
  if (totalProducts === 0) {
    elements.orangeBookData.innerHTML = `
      <div class="text-center p-4">
        <p class="text-sm text-gray-700">No Orange Book entries found</p>
      </div>
    `;
    return;
  }
  
  // Create a table for Orange Book products
  let html = `
    <div class="overflow-x-auto">
      <table class="min-w-full divide-y divide-gray-200">
        <thead class="bg-gray-50">
      <tr>
        <th class="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider">Trade Name</th>
        <th class="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider">Approval_Date
</th>
        <th class="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider">Strength</th>
      </tr>
        </thead>
        <tbody class="bg-white divide-y divide-gray-200">
  `;
  
  // Add rows for each product (limit to 10 for performance)
  const productsToShow = Math.min(data.results.products.length, 10);
  for (let i = 0; i < productsToShow; i++) {
    const product = data.results.products[i];
    console.log("o", product)
    html += `
        <tr class="hover:bg-gray-50">
          <td class="px-6 py-4 text-sm font-medium text-gray-700">${product.Trade_Name || 'N/A'}</td>
          <td class="px-6 py-4 text-sm text-gray-600">${product.Approval_Date
            || 'N/A'}</td>
          <td class="px-6 py-4 text-sm text-gray-600">${product.Strength || 'N/A'}</td>
        </tr>
    `;
  }
  
  html += `
        </tbody>
      </table>
    </div>
  `;
  
  // If there are more results than shown, add a note
  if (data.results.products.length > 10) {
    html += `
      <div class="text-xs text-gray-500 mt-2 text-right">
        Showing 10 of ${data.results.products.length} entries
      </div>
    `;
  }
  
  elements.orangeBookData.innerHTML = html;
}

// Function to display DailyMed data
function displayDailyMedData(data) {
  const labelInfo = data.label_info || [];
  
  // Update counter
  elements.dailyMedCount.textContent = `${labelInfo.length} entries`;
  
  if (labelInfo.length === 0) {
    elements.dailyMedData.innerHTML = `
      <div class="text-center p-4">
        <p class="text-sm text-gray-700">No DailyMed information found</p>
      </div>
    `;
    return;
  }
  
  // Create cards for each DailyMed entry
  let html = `<div class="grid grid-cols-1 md:grid-cols-2 gap-4">`;
  
  for (const label of labelInfo) {
    html += `
      <div class="bg-white border border-gray-200 rounded p-3">
        <h4 class="font-medium text-sm">${label.title}</h4>
        <p class="text-xs text-gray-500 mt-1">Published: ${label.published}</p>
        ${label.manufacturer ? `<p class="text-xs mt-1">Manufacturer: ${label.manufacturer}</p>` : ''}
        ${label.dosageForm ? `<p class="text-xs mt-1">Dosage Form: ${label.dosageForm}</p>` : ''}
        <div class="mt-2">
          <a href="${label.labelUrl}" target="_blank" class="text-xs text-blue-600 hover:underline">
            View on DailyMed
          </a>
        </div>
      </div>
    `;
  }
  
  html += `</div>`;
  elements.dailyMedData.innerHTML = html;
}

// Function to create and open the details modal
function openDetailsModal(applicationNumber, brandName, ingredient) {
  // Create modal if it doesn't exist
  if (!document.getElementById('detailsModal')) {
    const modalHTML = `
      <div id="detailsModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-lg shadow-xl w-11/12 max-w-4xl max-h-[90vh] overflow-auto">
          <div class="p-4 border-b flex justify-between items-center">
            <h3 class="text-lg font-semibold" id="modalTitle">Application Details</h3>
            <button id="closeModalBtn" class="text-gray-500 hover:text-gray-700">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
          
          <div class="p-6" id="modalContent">
            <div class="animate-pulse">
              <div class="h-4 bg-gray-200 rounded w-3/4 mb-4"></div>
              <div class="h-4 bg-gray-200 rounded w-1/2 mb-4"></div>
              <div class="h-4 bg-gray-200 rounded w-5/6 mb-4"></div>
            </div>
          </div>
          
          <div class="border-t p-4 flex justify-end">
            <button id="scrapeDocsBtn" class="px-4 py-2 bg-blue-600 text-white rounded mr-2 hover:bg-blue-700 transition-colors">
              Get Documents
            </button>
            <button id="aiSummaryBtn" class="px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 transition-colors" disabled>
              AI Summary
            </button>
          </div>
        </div>
      </div>
    `;
    
    // Append modal to body
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    
    // Add event listeners for modal
    document.getElementById('closeModalBtn').addEventListener('click', closeModal);
    
    // Close modal when clicking outside
    document.getElementById('detailsModal').addEventListener('click', function(e) {
      if (e.target === this) {
        closeModal();
      }
    });
  }
  
  // Update modal title
  document.getElementById('modalTitle').textContent = `${brandName} (${applicationNumber})`;
  
  // Show modal
  document.getElementById('detailsModal').classList.remove('hidden');
  
  // Store application number for document scraping
  document.getElementById('scrapeDocsBtn').setAttribute('data-application', applicationNumber);
  
  // Load details into modal
  loadModalDetails(applicationNumber, brandName, ingredient);
  
  // Add event listener for scraping
  document.getElementById('scrapeDocsBtn').addEventListener('click', function() {
    const appNo = this.getAttribute('data-application');
    scrapeDocuments(appNo);
  });
  
  // Add event listener for AI summary
  document.getElementById('aiSummaryBtn').addEventListener('click', function() {
    generateAISummary();
  });
}

// Function to close the modal
function closeModal() {
  document.getElementById('detailsModal').classList.add('hidden');
}

// Function to load details into the modal
async function loadModalDetails(applicationNumber, brandName, ingredient) {
  const modalContent = document.getElementById('modalContent');
  
  modalContent.innerHTML = `
    <div class="animate-pulse">
      <div class="h-4 bg-gray-200 rounded w-3/4 mb-4"></div>
      <div class="h-4 bg-gray-200 rounded w-1/2 mb-4"></div>
      <div class="h-4 bg-gray-200 rounded w-5/6 mb-4"></div>
    </div>
  `;
  
  try {
    // Fetch Orange Book data for this application
    const orangeBookResponse = await fetch(`/api/fda/orangebook/search?q=${encodeURIComponent(applicationNumber)}`);
    const orangeBookData = await orangeBookResponse.json();
    
    // Fetch DailyMed data for this ingredient
    const dailyMedResponse = await fetch(`/api/fda/dailymed/${encodeURIComponent(ingredient)}`);
    const dailyMedData = await dailyMedResponse.json();
    
    // Build content for modal
    let html = `
      <div class="mb-6">
        <h4 class="text-md font-semibold border-b pb-2 mb-2">Application Information</h4>
        <div class="grid grid-cols-2 gap-2 text-sm">
          <div>
            <p><span class="font-medium">Application Number:</span> ${applicationNumber}</p>
            <p><span class="font-medium">Brand Name:</span> ${brandName}</p>
            <p><span class="font-medium">Active Ingredient:</span> ${ingredient}</p>
          </div>
          <div class="text-right">
            <a href="https://www.accessdata.fda.gov/scripts/cder/daf/index.cfm?event=overview.process&ApplNo=${applicationNumber.replace(/[^0-9]/g, '')}" 
               target="_blank" 
               class="text-blue-600 hover:underline">
              View on FDA Website
            </a>
          </div>
        </div>
      </div>
      
      <div class="mb-6">
        <h4 class="text-md font-semibold border-b pb-2 mb-2">Orange Book Information</h4>
        ${renderOrangeBookDetails(orangeBookData)}
      </div>
      
      <div class="mb-6">
        <h4 class="text-md font-semibold border-b pb-2 mb-2">DailyMed Information</h4>
        ${renderDailyMedDetails(dailyMedData)}
      </div>
      
      <div id="documentSection" class="mb-6">
        <h4 class="text-md font-semibold border-b pb-2 mb-2">FDA Documents</h4>
        <p class="text-sm text-gray-600">Click "Get Documents" button below to retrieve FDA documents for this application.</p>
      </div>
    `;
    
    modalContent.innerHTML = html;
    
  } catch (error) {
    console.error("Error loading modal details:", error);
    modalContent.innerHTML = `
      <div class="text-center text-red-500 p-4">
        <p>Error loading details. Please try again.</p>
      </div>
    `;
  }
}

// Function to render Orange Book details
function renderOrangeBookDetails(data) {
  if (!data.results || data.results.products.length === 0) {
    return `<p class="text-sm text-gray-600">No Orange Book entries found for this application.</p>`;
  }
  
  let html = `
    <div class="overflow-x-auto">
      <table class="min-w-full divide-y divide-gray-200">
    <thead class="bg-blue-600 text-white">
      <tr>
        <th class="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider">Trade Name</th>
        <th class="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider">Approval</th>
        <th class="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider">Strength</th>
      </tr>
    </thead>
        <tbody class="bg-white divide-y divide-gray-200">
  `;
  
  // Limit to 5 products for performance
  const productsToShow = Math.min(data.results.products.length, 5);
  for (let i = 0; i < productsToShow; i++) {
    const product = data.results.products[i];
    console.log(product)
    html += `
        <tr class="hover:bg-gray-50">
          <td class="px-6 py-4 text-sm font-medium text-gray-700">${product.Trade_Name || 'N/A'}</td>
          <td class="px-6 py-4 text-sm text-gray-600">${product.Approval_Date
            || 'N/A'}</td>
          <td class="px-6 py-4 text-sm text-gray-600">${product.Strength || 'N/A'}</td>
        </tr>
    `;
  }
  
  html += `
        </tbody>
      </table>
    </div>
  `;
  
  return html;
}

// Function to render DailyMed details
function renderDailyMedDetails(data) {
  const labelInfo = data.label_info || [];
  
  if (labelInfo.length === 0) {
    return `<p class="text-sm text-gray-600">No DailyMed information found for this product.</p>`;
  }
  
  let html = `<div class="grid grid-cols-1 gap-3">`;
  
  // Display up to 3 entries
  const entriesToShow = Math.min(labelInfo.length, 3);
  for (let i = 0; i < entriesToShow; i++) {
    const label = labelInfo[i];
    html += `
      <div class="bg-gray-50 rounded p-3">
        <h5 class="font-medium text-sm">${label.title}</h5>
        <p class="text-xs text-gray-500 mt-1">Published: ${label.published}</p>
        ${label.manufacturer ? `<p class="text-xs mt-1">Manufacturer: ${label.manufacturer}</p>` : ''}
        <div class="mt-2">
          <a href="${label.labelUrl}" target="_blank" class="text-xs text-blue-600 hover:underline">
            View on DailyMed
          </a>
        </div>
      </div>
    `;
  }
  
  html += `</div>`;
  
  // If there are more entries than shown
  if (labelInfo.length > 3) {
    html += `
      <div class="text-xs text-gray-500 mt-2">
        Showing 3 of ${labelInfo.length} entries
      </div>
    `;
  }
  
  return html;
}

// Function to scrape FDA documents
// Function to scrape FDA documents
async function scrapeDocuments(applicationNumber) {
    console.log(applicationNumber)
  const documentSection = document.getElementById('documentSection');
  const aiSummaryBtn = document.getElementById('aiSummaryBtn');
  
  // Show loading state
  documentSection.innerHTML = `
    <h4 class="text-md font-semibold border-b pb-2 mb-2">FDA Documents</h4>
    <div class="flex justify-center items-center py-4">
      <svg class="animate-spin h-5 w-5 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
      <span class="ml-2 text-gray-600">Retrieving documents...</span>
    </div>
  `;
  
  try {
    // Use the new endpoint to fetch document links
    const appNo = applicationNumber.replace(/[^0-9]/g, ''); // Clean the application number
    const response = await fetch(`/api/fda-pdfs/${appNo}`);
    
if (!response.ok) {
  const contentType = response.headers.get("content-type");
  if (contentType && contentType.indexOf("application/json") === -1) {
    // Not JSON - probably HTML error page
    throw new Error(`Received non-JSON response (${response.status})`);
  }
  throw new Error(`HTTP error ${response.status}`);
}
    
    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }
    
    const data = await response.json();
    const documentLinks = data.results || [];
    
    // Update the document section with links
    let html = `
      <h4 class="text-md font-semibold border-b pb-2 mb-2">FDA Documents</h4>
      <div class="mt-3">
    `;
    
    if (documentLinks.length === 0) {
      html += `<p class="text-sm text-gray-600">No documents found for this application.</p>`;
    } else {
      // Group documents by type
      const groupedDocs = {};
      documentLinks.forEach(link => {
        if (!groupedDocs[link.type]) {
          groupedDocs[link.type] = [];
        }
        groupedDocs[link.type].push(link);
      });
      
      // Display documents by type
      for (const [type, links] of Object.entries(groupedDocs)) {
        html += `
          <div class="mb-3">
            <h5 class="text-sm font-medium mb-2">${type} Documents (${links.length})</h5>
            <ul class="list-disc pl-5 text-sm">
        `;
        
        for (const link of links) {
          html += `
            <li class="mb-1">
              <a href="${link.url}" target="_blank" class="text-blue-600 hover:underline">
                ${link.name}
              </a>
            </li>
          `;
        }
        
        html += `
            </ul>
          </div>
        `;
      }
      
      // Add note about documents
      html += `
        <p class="text-xs text-gray-500 mt-3">
          Found ${documentLinks.length} documents. Some links may require FDA authentication.
        </p>
      `;
    }
    
    html += `</div>`;
    
    // Update the document section
    documentSection.innerHTML = html;
    
    // Store document data for AI summary
    document.getElementById('aiSummaryBtn').setAttribute('data-documents', JSON.stringify(documentLinks));
    
    // Enable AI summary button if we have documents
    if (documentLinks.length > 0) {
      aiSummaryBtn.disabled = false;
    }
    
  } catch (error) {
    console.error("Error retrieving documents:", error);
    documentSection.innerHTML = `
      <h4 class="text-md font-semibold border-b pb-2 mb-2">FDA Documents</h4>
      <div class="text-center text-red-500 p-4">
        <p>Error retrieving documents: ${error.message}</p>
        <button id="retryFetchBtn" class="mt-2 px-3 py-1 bg-blue-500 text-white text-xs rounded hover:bg-blue-600">
          Retry
        </button>
      </div>
    `;
    
    // Add retry button functionality
    document.getElementById('retryFetchBtn').addEventListener('click', () => {
      scrapeDocuments(applicationNumber);
    });
  }
}
// Function to generate AI summary of documents
// Function to generate AI summary of documents
// Modified function to generate AI summary of documents
async function generateAISummary() {
  const modalContent = document.getElementById('modalContent');
  const aiSummaryBtn = document.getElementById('aiSummaryBtn');
  const currentContent = modalContent.innerHTML;
  
  // Get document data stored in the button's data attribute
  let documentLinks = [];
  try {
    documentLinks = JSON.parse(aiSummaryBtn.getAttribute('data-documents') || '[]');
  } catch (error) {
    console.error("Error parsing document data:", error);
  }
  
  // Count document types
  const docTypeCounts = {};
  documentLinks.forEach(doc => {
    docTypeCounts[doc.type] = (docTypeCounts[doc.type] || 0) + 1;
  });
  
  const docTypeSummary = Object.entries(docTypeCounts)
    .map(([type, count]) => `${count} ${type}${count > 1 ? 's' : ''}`)
    .join(', ');
  
  // Append AI summary section with loading state
  modalContent.innerHTML = currentContent + `
    <div id="aiSummarySection" class="mt-6 border-t pt-4">
      <h4 class="text-md font-semibold border-b pb-2 mb-2">AI Document Summary</h4>
      <div class="bg-purple-50 p-4 rounded">
        <div class="flex items-center mb-3">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-purple-600 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
          </svg>
          <span class="font-medium text-purple-700">AI Analysis</span>
        </div>
        
        <div id="aiSummaryContent">
          <div class="flex justify-center items-center py-4">
            <svg class="animate-spin h-5 w-5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
              <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <span class="ml-2 text-gray-600">Analyzing documents...</span>
          </div>
        </div>
      </div>
    </div>
  `;
  
  // Find PDF document links (with priority order)
  const pdfLinks = documentLinks.filter(doc => doc.url.toLowerCase().endsWith('.pdf'));
  
  // Priority order: Label > Review > Letter > Other
  const labelDocs = pdfLinks.filter(doc => doc.type === 'Label');
  const reviewDocs = pdfLinks.filter(doc => doc.type === 'Review');
  const letterDocs = pdfLinks.filter(doc => doc.type === 'Letter');
  
  // Choose documents to analyze based on priority
  let docsToAnalyze = [];
  if (labelDocs.length > 0) {
    docsToAnalyze = labelDocs;
  } else if (reviewDocs.length > 0) {
    docsToAnalyze = reviewDocs;
  } else if (letterDocs.length > 0) {
    docsToAnalyze = letterDocs;
  } else {
    docsToAnalyze = pdfLinks;
  }
  
  if (docsToAnalyze.length === 0) {
    // No PDF documents found
    document.getElementById('aiSummaryContent').innerHTML = `
      <div class="text-center text-gray-600 p-4">
        <p>No PDF documents found to analyze. AI summary unavailable.</p>
      </div>
    `;
    return;
  }
  
  try {
    // Choose the first document for analysis
    const docToAnalyze = docsToAnalyze[0];
    
    // Update status message
    document.getElementById('aiSummaryContent').innerHTML = `
      <div class="flex flex-col items-center py-4">
        <div class="flex items-center">
          <svg class="animate-spin h-5 w-5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
          <span class="ml-2 text-gray-600">Analyzing document...</span>
        </div>
        <div class="mt-2 text-xs text-gray-500">
          Processing: ${docToAnalyze.name} (${docToAnalyze.type})
        </div>
      </div>
    `;
    
    // Call backend to analyze the document
    const response = await fetch('/api/analyze-fda-doc', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        pdfUrl: docToAnalyze.url
      })
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`API request failed (${response.status}): ${errorText}`);
    }
    
    const result = await response.json();
    
    if (result.error) {
      throw new Error(result.error);
    }
    
    // Display the summary with enhanced formatting
    document.getElementById('aiSummaryContent').innerHTML = `
      <div class="mt-1 text-sm bg-white p-4 rounded border border-purple-100 prose">
        ${result.summary}
      </div>
      
      <div class="mt-3 flex justify-between items-center text-xs text-gray-500">
        <span>Document: ${docToAnalyze.type} - ${docToAnalyze.name.length > 40 ? docToAnalyze.name.substring(0, 40) + '...' : docToAnalyze.name}</span>
        ${result.imageCount > 0 ? `<span>Images analyzed: ${result.imageCount}</span>` : ''}
      </div>
    `;
    
  } catch (error) {
    console.error("Error generating AI summary:", error);
    document.getElementById('aiSummaryContent').innerHTML = `
      <div class="text-center text-red-500 p-4">
        <p>Error generating AI summary: ${error.message}</p>
        <button id="retryAnalysisBtn" class="mt-2 px-3 py-1 bg-purple-500 text-white text-xs rounded hover:bg-purple-600">
          Retry Analysis
        </button>
      </div>
    `;
    
    // Add retry button functionality
    document.getElementById('retryAnalysisBtn').addEventListener('click', () => {
      generateAISummary();
    });
  }
}



function createStatisticalSummaryTable(outcomes) {
    const table = elements.statisticalSummaryTable;
    if (!table) {
        console.warn("Statistical summary table element not found");
        return;
    }
    
    table.innerHTML = '';
    
    // Filter only outcomes with effect sizes
    const validOutcomes = outcomes.filter(o => o.effectSize !== null);
    
    if (validOutcomes.length === 0) {
        table.innerHTML = '<tr><td colspan="6" class="py-4 text-center text-gray-500">No statistical data available for the selected metric.</td></tr>';
        return;
    }
    
    // Group outcomes by study first
    const studyOutcomes = {};
    
    validOutcomes.forEach(o => {
        const nctId = o.nctId;
        if (!studyOutcomes[nctId]) {
            studyOutcomes[nctId] = [];
        }
        studyOutcomes[nctId].push(o);
    });
    
    // Calculate average effect size for each study to avoid over-counting 
    // studies with multiple outcomes
    const studyEffects = Object.entries(studyOutcomes).map(([nctId, outcomes]) => {
        const effectSizes = outcomes.map(o => o.effectSize);
        const meanEffect = calculateMean(effectSizes);
        const phase = outcomes[0].phase || 'N/A';
        
        return {
            nctId,
            phase,
            effectSize: meanEffect,
            experimentalValue: outcomes[0].experimentalValue,
            controlValue: outcomes[0].controlValue,
            experimentalSampleSize: outcomes[0].experimentalSampleSize,
            controlSampleSize: outcomes[0].controlSampleSize
        };
    });
    
    // Now group by phase
    const phaseGroups = {};
    const phaseOrder = { 
        "PRE_PHASE": 0, 
        "PHASE1": 1, 
        "PHASE1_PHASE2": 1.5,
        "PHASE2": 2, 
        "PHASE3": 3, 
        "PHASE4": 4,
        "N/A": 5
    };
    
    studyEffects.forEach(effect => {
        const phase = effect.phase;
        if (!phaseGroups[phase]) {
            phaseGroups[phase] = {
                effectSizes: [],
                experimentalValues: [],
                controlValues: [],
                experimentalSampleSizes: [],
                controlSampleSizes: []
            };
        }
        
        phaseGroups[phase].effectSizes.push(effect.effectSize);
        
        if (effect.experimentalValue !== null) {
            phaseGroups[phase].experimentalValues.push(effect.experimentalValue);
            phaseGroups[phase].experimentalSampleSizes.push(effect.experimentalSampleSize || 0);
        }
        
        if (effect.controlValue !== null) {
            phaseGroups[phase].controlValues.push(effect.controlValue);
            phaseGroups[phase].controlSampleSizes.push(effect.controlSampleSize || 0);
        }
    });
    
    // Add an "All Phases" row at the top
    let allEffectSizes = studyEffects.map(e => e.effectSize);
    let allExperimentalValues = studyEffects.filter(e => e.experimentalValue !== null).map(e => e.experimentalValue);
    let allControlValues = studyEffects.filter(e => e.controlValue !== null).map(e => e.controlValue);
    let allExperimentalSampleSizes = studyEffects.filter(e => e.experimentalSampleSize > 0).map(e => e.experimentalSampleSize);
    let allControlSampleSizes = studyEffects.filter(e => e.controlSampleSize > 0).map(e => e.controlSampleSize);
    
    // Calculate overall statistics
    const overallMean = calculateMean(allEffectSizes);
    const overallStdDev = calculateStandardDeviation(allEffectSizes, overallMean);
    const overallN = studyEffects.length; // Count unique studies
    const overallCi = calculateConfidenceInterval(overallMean, overallStdDev, overallN);
    
    const totalExperimentalN = allExperimentalSampleSizes.reduce((sum, n) => sum + n, 0);
    const totalControlN = allControlSampleSizes.reduce((sum, n) => sum + n, 0);
    
    // Add overall row
    const row = document.createElement('tr');
    row.className = 'bg-gray-50 font-medium';
    row.innerHTML = `
        <td class="py-2 px-4 border-b">All Phases</td>
        <td class="py-2 px-4 border-b">${overallN}</td>
        <td class="py-2 px-4 border-b">${overallMean.toFixed(2)}</td>
        <td class="py-2 px-4 border-b">${overallStdDev.toFixed(2)}</td>
        <td class="py-2 px-4 border-b">${overallCi.lower.toFixed(2)} to ${overallCi.upper.toFixed(2)}</td>
        <td class="py-2 px-4 border-b">${calculatePValue(
            calculateMean(allExperimentalValues),
            calculateMean(allControlValues),
            calculateStandardDeviation(allExperimentalValues),
            calculateStandardDeviation(allControlValues),
            totalExperimentalN,
            totalControlN
        )}</td>
    `;
    table.appendChild(row);
    
    // Add phase-specific rows
    Object.keys(phaseGroups)
        .sort((a, b) => phaseOrder[a] - phaseOrder[b])
        .forEach(phase => {
            const data = phaseGroups[phase];
            
            // Calculate statistics for this phase
            const mean = calculateMean(data.effectSizes);
            const stdDev = calculateStandardDeviation(data.effectSizes, mean);
            const n = data.effectSizes.length;
            const ci = calculateConfidenceInterval(mean, stdDev, n);
            
            const expMean = calculateMean(data.experimentalValues);
            const ctrlMean = calculateMean(data.controlValues);
            const expStdDev = calculateStandardDeviation(data.experimentalValues);
            const ctrlStdDev = calculateStandardDeviation(data.controlValues);
            
            const totalExpN = data.experimentalSampleSizes.reduce((sum, n) => sum + n, 0);
            const totalCtrlN = data.controlSampleSizes.reduce((sum, n) => sum + n, 0);
            
            const row = document.createElement('tr');
            row.innerHTML = `
                <td class="py-2 px-4 border-b">${formatPhase(phase)}</td>
                <td class="py-2 px-4 border-b">${n}</td>
                <td class="py-2 px-4 border-b">${mean.toFixed(2)}</td>
                <td class="py-2 px-4 border-b">${stdDev.toFixed(2)}</td>
                <td class="py-2 px-4 border-b">${ci.lower.toFixed(2)} to ${ci.upper.toFixed(2)}</td>
                <td class="py-2 px-4 border-b">${calculatePValue(expMean, ctrlMean, expStdDev, ctrlStdDev, totalExpN, totalCtrlN)}</td>
            `;
            table.appendChild(row);
        });
}
        // Filter functions
        function filterStudiesByPhase(phase) {
            if (phase === 'all') {
                return appState.studies;
            } else {
                return appState.studies.filter(study => 
                    study.protocolSection?.designModule?.phases?.[0] === phase
                );
            }
        }

        // Utility functions
        function getRandomColor(index, alpha = 1) {
            const colors = [
                `rgba(59, 130, 246, ${alpha})`, // blue-500
                `rgba(16, 185, 129, ${alpha})`, // emerald-500
                `rgba(139, 92, 246, ${alpha})`, // violet-500
                `rgba(249, 115, 22, ${alpha})`, // orange-500
                `rgba(236, 72, 153, ${alpha})`, // pink-500
                `rgba(14, 165, 233, ${alpha})`, // sky-500
                `rgba(168, 85, 247, ${alpha})`, // purple-500
                `rgba(234, 88, 12, ${alpha})`, // amber-600
                `rgba(22, 163, 74, ${alpha})`, // green-600
                `rgba(79, 70, 229, ${alpha})` // indigo-600
            ];
            
            return colors[index % colors.length];
        }

        function hexToRgba(hex, alpha = 1) {
            // Handle color names that aren't hex
            if (!hex.startsWith('#')) {
                // Simple mapping of common colors
                const colorMap = {
                    'red': 'rgba(255, 0, 0, ' + alpha + ')',
                    'green': 'rgba(0, 255, 0, ' + alpha + ')',
                    'blue': 'rgba(0, 0, 255, ' + alpha + ')',
                    'black': 'rgba(0, 0, 0, ' + alpha + ')',
                    'white': 'rgba(255, 255, 255, ' + alpha + ')',
                    'gray': 'rgba(128, 128, 128, ' + alpha + ')',
                    'yellow': 'rgba(255, 255, 0, ' + alpha + ')',
                    'orange': 'rgba(255, 165, 0, ' + alpha + ')',
                    'purple': 'rgba(128, 0, 128, ' + alpha + ')'
                };
                if (colorMap[hex.toLowerCase()]) {
                    return colorMap[hex.toLowerCase()];
                }
                
                // For unknown colors, return a safe default
                return `rgba(128, 128, 128, ${alpha})`;
            }
            
            // Regular hex color handling
            let r = 0, g = 0, b = 0;
            
            // 3 digits
            if (hex.length === 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            } 
            // 6 digits
            else if (hex.length === 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            }
            // Handle other cases with a default
            else {
                return `rgba(128, 128, 128, ${alpha})`;
            }
            
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // Event handlers
        function handlePhaseFilter(event) {
            if (!event.target.classList.contains('phase-filter')) return;
            
            const phase = event.target.dataset.phase;
            
            // Update state
            appState.currentPhaseFilter = phase;
            
            // Update filter button styles
            document.querySelectorAll('.phase-filter').forEach(btn => {
                btn.classList.remove('bg-primary', 'text-white');
                btn.classList.add('bg-gray-200', 'hover:bg-gray-300');
            });
            event.target.classList.remove('bg-gray-200', 'hover:bg-gray-300');
            event.target.classList.add('bg-primary', 'text-white');
            
            // Filter studies
            const filteredStudies = filterStudiesByPhase(phase);
            
            // Update studies display
            displayStudies(filteredStudies);
        }

// async function handleSearch() {
//     const drug = elements.drugSearch.value.trim();
//     const condition = elements.conditionSearch.value.trim();
//     const hasResultsOnly = elements.hasResultsOnly.checked;
//     const trdFocusOnly = elements.trdFocusOnly.checked;
    
//     if (!drug) {
//         alert('Please enter a drug name to search.');
//         return;
//     }
    
//     // Update state
//     appState.hasResultsOnly = hasResultsOnly;
//     appState.trdFocusOnly = trdFocusOnly;
//     appState.currentPhaseFilter = 'all';
//     appState.studies = [];
//     appState.studyDetails = {};
//     appState.allOutcomeMeasures = [];
//     appState.collatedOutcomes = [];
//     appState.failedStudyIds.clear(); // Reset failed study IDs
    
//     // Reset FDA data
//     appState.fdaData = {
//         documents: [],
//         orangeBook: [],
//         dailyMed: [],
//         warningLetters: []
//     };
    
//     // Reset phase filter buttons
//     document.querySelectorAll('.phase-filter').forEach(btn => {
//         btn.classList.remove('bg-primary', 'text-white');
//         btn.classList.add('bg-gray-200', 'hover:bg-gray-300');
//     });
//     document.querySelector('.phase-filter[data-phase="all"]').classList.remove('bg-gray-200', 'hover:bg-gray-300');
//     document.querySelector('.phase-filter[data-phase="all"]').classList.add('bg-primary', 'text-white');
    
//     // Hide sections and show loading
//     showSection(elements.resultsOverview, false);
//     showSection(elements.studiesSection, false);
//     // showSection(elements.aggregateOutcomesSection, false);
//     // showSection(elements.collatedOutcomesSection, false);
//     showSection(elements.studyDetailSection, false);
//     showSection(elements.fdaDataSection, false);
//     // showSection(elements.drugSuccessSection, false); // Hide drug success section
//     displayLoading(true);
    
//     try {
//         console.log(`Searching for studies - Drug: ${drug}, Condition: ${condition}, Results Only: ${hasResultsOnly}, TRD Focus: ${trdFocusOnly}`);
        
//         // Fetch studies
//         const studies = await fetchStudies(drug, condition, hasResultsOnly);
//         console.log(`Retrieved ${studies.length} studies`);
        
//         // Filter for TRD-specific studies if requested
//         let filteredStudies = studies;
//         if (trdFocusOnly) {
//             filteredStudies = filterTRDSpecificStudies(studies);
//             console.log(`Filtered to ${filteredStudies.length} TRD-specific studies`);
//         }
        
//         appState.studies = filteredStudies;
        
//         if (filteredStudies.length === 0) {
//             elements.placeholderMessage.innerHTML = `
//                 <div class="text-center">
//                     <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mx-auto text-gray-400 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
//                         <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
//                     </svg>
//                     <p class="text-lg">No ${trdFocusOnly ? 'TRD-specific ' : ''}studies found for "${drug}".</p>
//                     <p class="mt-2 text-sm">Try another drug name${trdFocusOnly ? ' or disable the TRD-specific filter' : ''}.</p>
//                 </div>
//             `;
//             // Still show FDA data even if no studies are found
//             displayFdaData(drug);
//             displayLoading(false);
//             return;
//         }

//         // 
        
//         // Display results summary
//         displayResultsSummary(filteredStudies);
//         // showSection(elements.resultsOverview, true);
        
//         // Display studies list
//         displayStudies(filteredStudies);
//         showSection(elements.studiesSection, true);
        
//         // Display FDA data section
//         displayFdaData(drug);
        
//         // Fetch study details for studies with results
//         appState.studyDetails = {};
//         const studiesWithResults = filteredStudies.filter(study => study.hasResults);
//         console.log(`Fetching details for ${studiesWithResults.length} studies with results`);
        
//          // Ensure chart canvases are created
//         //  ensureChartCanvasesExist();
//         //  ensureDrugSuccessChartCanvasesExist();
//         // Use a semaphore to limit concurrent API calls
//         const MAX_CONCURRENT_REQUESTS = 5;
//         let activeRequests = 0;
//         let requestQueue = [...studiesWithResults];
//         let completedRequests = 0;
        
//         const processQueue = async () => {
//             if (requestQueue.length === 0) return;
            
//             while (activeRequests < MAX_CONCURRENT_REQUESTS && requestQueue.length > 0) {
//                 activeRequests++;
//                 const study = requestQueue.shift();
//                 const nctId = study.protocolSection.identificationModule.nctId;
                
//                 fetchStudyDetails(nctId).then(details => {
//                     if (details) {
//                         appState.studyDetails[nctId] = details;
//                     }
                    
//                     activeRequests--;
//                     completedRequests++;
                    
//                     // Update progress if we have a lot of studies
//                     if (studiesWithResults.length > 10 && completedRequests % 5 === 0) {
//                         const progressPercent = Math.round((completedRequests / studiesWithResults.length) * 100);
//                         console.log(`Study details progress: ${progressPercent}% (${completedRequests}/${studiesWithResults.length})`);
//                     }
                    
//                     // Process more from queue
//                     processQueue();
                    
//                     // If all requests are complete, process the outcomes
//                     if (activeRequests === 0 && requestQueue.length === 0) {
//                         console.log('All study details fetched, processing outcomes');
//                         // Process and display aggregate outcomes
//                         processAggregateOutcomes(filteredStudies);
//                         displayLoading(false);
//                     }
//                 });
//             }
//         };
        
//         // Start processing the queue
//         await processQueue();
        
//         // If no studies with results, hide loading
//         if (studiesWithResults.length === 0) {
//             displayLoading(false);
//         }
        
//     } catch (error) {
//         console.error('Error during search:', error);
//         elements.placeholderMessage.innerHTML = `
//             <div class="text-center">
//                 <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mx-auto text-red-500 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
//                     <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
//                 </svg>
//                 <p class="text-lg">Error searching for studies</p>
//                 <p class="mt-2 text-sm">Please try again later.</p>
//                 <p class="mt-2 text-xs text-gray-500">${error.message}</p>
//             </div>
//         `;
//         displayLoading(false);
//     }
// }


async function handleSearch() {
    const drug = elements.drugSearch.value.trim();
    const condition = elements.conditionSearch.value.trim();
    const hasResultsOnly = elements.hasResultsOnly.checked;
    const trdFocusOnly = elements.trdFocusOnly.checked;
    
    if (!drug) {
        alert('Please enter a drug name to search.');
        return;
    }
    
    // Update state
    appState.hasResultsOnly = hasResultsOnly;
    appState.trdFocusOnly = trdFocusOnly;
    appState.currentPhaseFilter = 'all';
    appState.studies = [];
    appState.studyDetails = {};
    appState.failedStudyIds.clear(); // Reset failed study IDs
    
    // Reset FDA data
    appState.fdaData = {
        documents: [],
        orangeBook: [],
        dailyMed: [],
        warningLetters: []
    };
    
    // Reset phase filter buttons
    document.querySelectorAll('.phase-filter').forEach(btn => {
        btn.classList.remove('bg-primary', 'text-white');
        btn.classList.add('bg-gray-200', 'hover:bg-gray-300');
    });
    document.querySelector('.phase-filter[data-phase="all"]').classList.remove('bg-gray-200', 'hover:bg-gray-300');
    document.querySelector('.phase-filter[data-phase="all"]').classList.add('bg-primary', 'text-white');
    
    // Hide sections and show loading
    showSection(elements.resultsOverview, false);
    showSection(elements.studiesSection, false);
    showSection(elements.studyDetailSection, false);
    showSection(elements.fdaDataSection, false);
    displayLoading(true);
    
    try {
        console.log(`Searching for studies - Drug: ${drug}, Condition: ${condition}, Results Only: ${hasResultsOnly}, TRD Focus: ${trdFocusOnly}`);
        
        // Fetch studies
        const studies = await fetchStudies(drug, condition, hasResultsOnly);
        console.log(`Retrieved ${studies.length} studies`);
        
        // Filter for TRD-specific studies if requested
        let filteredStudies = studies;
        if (trdFocusOnly) {
            filteredStudies = filterTRDSpecificStudies(studies);
            console.log(`Filtered to ${filteredStudies.length} TRD-specific studies`);
        }
        
        appState.studies = filteredStudies;
        collectAllTrialOutcomes()

        
        if (filteredStudies.length === 0) {
            elements.placeholderMessage.innerHTML = `
                <div class="text-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mx-auto text-gray-400 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                    <p class="text-lg">No ${trdFocusOnly ? 'TRD-specific ' : ''}studies found for "${drug}".</p>
                    <p class="mt-2 text-sm">Try another drug name${trdFocusOnly ? ' or disable the TRD-specific filter' : ''}.</p>
                </div>
            `;
            // Still show FDA data even if no studies are found
            displayFdaData(drug);
            displayLoading(false);
            return;
        }
        
        // Display results summary
        displayResultsSummary(filteredStudies);
        showSection(elements.resultsOverview, true);
        
        // Display studies list
        displayStudies(filteredStudies);
        showSection(elements.studiesSection, true);
        
        // Display FDA data section
        displayFdaData(drug);
        
        
        // Fetch study details for studies with results
        appState.studyDetails = {};
        const studiesWithResults = filteredStudies.filter(study => study.hasResults);
        console.log(`Fetching details for ${studiesWithResults.length} studies with results`);
        
        // Use a semaphore to limit concurrent API calls
        const MAX_CONCURRENT_REQUESTS = 5;
        let activeRequests = 0;
        let requestQueue = [...studiesWithResults];
        let completedRequests = 0;
        
        const processQueue = async () => {
            if (requestQueue.length === 0) return;
            
            while (activeRequests < MAX_CONCURRENT_REQUESTS && requestQueue.length > 0) {
                activeRequests++;
                const study = requestQueue.shift();
                const nctId = study.protocolSection.identificationModule.nctId;
                
                fetchStudyDetails(nctId).then(details => {
                    if (details) {
                        appState.studyDetails[nctId] = details;
                    }
                    
                    activeRequests--;
                    completedRequests++;
                    
                    // Update progress if we have a lot of studies
                    if (studiesWithResults.length > 10 && completedRequests % 5 === 0) {
                        const progressPercent = Math.round((completedRequests / studiesWithResults.length) * 100);
                        console.log(`Study details progress: ${progressPercent}% (${completedRequests}/${studiesWithResults.length})`);
                    }
                    
                    // Process more from queue
                    processQueue();
                    
                    // If all requests are complete
                    if (activeRequests === 0 && requestQueue.length === 0) {
                        console.log('All study details fetched');
                        collectAllTrialOutcomes()
                        displayLoading(false);
                    }
                });
            }
        };
        
        // Start processing the queue
        await processQueue();
        
        // If no studies with results, hide loading
        if (studiesWithResults.length === 0) {
            displayLoading(false);
        }
        
    } catch (error) {
        console.error('Error during search:', error);
        elements.placeholderMessage.innerHTML = `
            <div class="text-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mx-auto text-red-500 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <p class="text-lg">Error searching for studies</p>
                <p class="mt-2 text-sm">Please try again later.</p>
                <p class="mt-2 text-xs text-gray-500">${error.message}</p>
            </div>
        `;
        displayLoading(false);
    }
}

function extractCommonDepressionMeasures() {
    if (appState.allTrialOutcomes.length === 0) return [];
    
    // Collect all depression-related outcome measures
    const depressionMeasures = new Map();
    
    appState.allTrialOutcomes.forEach(study => {
        study.outcomes.forEach(outcome => {
            const title = outcome.title;
            const titleLower = title.toLowerCase();
            
            // Check if this is a depression scale
            if (titleLower.includes('depression') || 
                titleLower.includes('madrs') || 
                titleLower.includes('ham-d') || 
                titleLower.includes('hamd') || 
                titleLower.includes('qids') || 
                titleLower.includes('beck') || 
                titleLower.includes('phq')) {
                
                if (!depressionMeasures.has(title)) {
                    depressionMeasures.set(title, {
                        title,
                        count: 0,
                        studies: new Set(),
                        experimentalValues: [],
                        controlValues: [],
                        effectSizes: []
                    });
                }
                
                const measureData = depressionMeasures.get(title);
                measureData.count++;
                measureData.studies.add(study.nctId);
                
                if (outcome.experimentalValue !== null) {
                    measureData.experimentalValues.push(outcome.experimentalValue);
                }
                
                if (outcome.controlValue !== null) {
                    measureData.controlValues.push(outcome.controlValue);
                }
                
                if (outcome.effectSize !== null) {
                    measureData.effectSizes.push(outcome.effectSize);
                }
            }
        });
    });
    
    // Convert to array and add statistics
    const result = Array.from(depressionMeasures.values()).map(measure => {
        return {
            title: measure.title,
            count: measure.count,
            studyCount: measure.studies.size,
            avgExperimental: measure.experimentalValues.length > 0 ? 
                calculateMean(measure.experimentalValues) : null,
            avgControl: measure.controlValues.length > 0 ? 
                calculateMean(measure.controlValues) : null,
            avgEffectSize: measure.effectSizes.length > 0 ? 
                calculateMean(measure.effectSizes) : null
        };
    });
    
    // Sort by frequency
    result.sort((a, b) => b.count - a.count);
    
    return result;
}

// Function to create a combined view of treatment efficacy across all depression measures
function createCombinedMeasuresChart() {
    const measures = extractCommonDepressionMeasures();
    if (measures.length === 0) return;
    
    // Get the most common measure to use for comparison
    const commonMeasure = measures[0];
    
    console.log(`Most common depression measure: ${commonMeasure.title} (used in ${commonMeasure.studyCount} studies)`);
    
    // Create a section for this visualization if it doesn't exist
    let measuresSection = document.getElementById('combinedMeasuresSection');
    if (!measuresSection) {
        try {
            const drugSuccessSection = document.getElementById('drugSuccessSection');
            if (!drugSuccessSection) {
                console.error("Drug success section not found, cannot add combined measures section");
                return;
            }
            
            // Create section after the drug success section
            measuresSection = document.createElement('section');
            measuresSection.id = 'combinedMeasuresSection';
            measuresSection.className = 'hidden mb-6'; // Start hidden
            measuresSection.innerHTML = `
                <div class="bg-white rounded-lg shadow-md p-6">
                    <h2 class="text-xl font-semibold mb-4">Treatment Efficacy Across Depression Measures</h2>
                    <p class="text-sm text-gray-600 mb-4">Combined analysis of all trials using standardized depression measures.</p>
                    <div class="mb-6">
                        <h3 class="text-lg font-medium mb-3">Depression Rating Scale Comparison</h3>
                        <div class="h-72">
                            <canvas id="combinedMeasuresChart"></canvas>
                        </div>
                    </div>
                    <div class="mb-6">
                        <h3 class="text-lg font-medium mb-3">Most Common Depression Measures</h3>
                        <div class="overflow-x-auto">
                            <table class="min-w-full bg-white border border-gray-200">
                                <thead>
                                    <tr>
                                        <th class="py-2 px-4 border-b text-left">Measure</th>
                                        <th class="py-2 px-4 border-b text-left">Studies</th>
                                        <th class="py-2 px-4 border-b text-left">Data Points</th>
                                        <th class="py-2 px-4 border-b text-left">Avg. Effect Size</th>
                                    </tr>
                                </thead>
                                <tbody id="measuresSummaryTable">
                                    <!-- Will be populated dynamically -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `;
            
            drugSuccessSection.parentNode.insertBefore(measuresSection, drugSuccessSection.nextSibling);
            
            // Add references to the elements object
            elements.combinedMeasuresSection = measuresSection;
            elements.measuresSummaryTable = document.getElementById('measuresSummaryTable');
            
            // Show the section
            showSection(measuresSection, true);
        } catch (error) {
            console.error("Error creating combined measures section:", error);
            return;
        }
    } else {
        // Show the section if it exists
        showSection(measuresSection, true);
    }
    
    try {
        // Create the chart
        const canvas = document.getElementById('combinedMeasuresChart');
        if (!canvas) {
            console.error("Combined measures chart canvas not found");
            return;
        }
        
        // Clear any previous chart
        if (charts.combinedMeasures) {
            charts.combinedMeasures.destroy();
        }
        
        // Filter to measures with effect sizes
        const measuresWithEffects = measures.filter(m => m.avgEffectSize !== null);
        
        if (measuresWithEffects.length === 0) {
            canvas.parentElement.innerHTML = '<p class="text-center text-gray-500 py-8">No effect size data available for comparison.</p>';
            return;
        }
        
        const ctx = canvas.getContext('2d');
        
        // Create the chart
        charts.combinedMeasures = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: measuresWithEffects.map(m => m.title),
                datasets: [{
                    label: 'Average Effect Size',
                    data: measuresWithEffects.map(m => m.avgEffectSize),
                    backgroundColor: measuresWithEffects.map((_, i) => getColorByIndex(i, 0.7)),
                    borderColor: measuresWithEffects.map((_, i) => getColorByIndex(i)),
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Average Effect Size'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Depression Measure'
                        },
                        ticks: {
                            callback: function(value) {
                                // Truncate long labels
                                const label = this.getLabelForValue(value);
                                if (label.length > 25) {
                                    return label.substring(0, 22) + '...';
                                }
                                return label;
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            title: function(context) {
                                return measuresWithEffects[context[0].dataIndex].title;
                            },
                            label: function(context) {
                                const measure = measuresWithEffects[context.dataIndex];
                                return [
                                    `Effect Size: ${measure.avgEffectSize.toFixed(2)}`,
                                    `Studies: ${measure.studyCount}`,
                                    `Data Points: ${measure.count}`
                                ];
                            }
                        }
                    }
                }
            }
        });
        
        // Fill the measures summary table
        const table = elements.measuresSummaryTable;
        if (table) {
            table.innerHTML = '';
            
            measures.forEach(measure => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="py-2 px-4 border-b">${measure.title}</td>
                    <td class="py-2 px-4 border-b">${measure.studyCount}</td>
                    <td class="py-2 px-4 border-b">${measure.count}</td>
                    <td class="py-2 px-4 border-b">${measure.avgEffectSize !== null ? measure.avgEffectSize.toFixed(2) : 'N/A'}</td>
                `;
                table.appendChild(row);
            });
        }
    } catch (error) {
        console.error("Error rendering combined measures chart:", error);
        
        // Add error message to section
        measuresSection.querySelector('.bg-white').innerHTML += `
            <div class="bg-red-50 text-red-700 p-4 rounded-lg mt-4">
                <p>Error creating depression measures chart: ${error.message}</p>
                <p class="text-sm mt-2">This is likely due to insufficient data in the available studies.</p>
            </div>
        `;
    }
}
// New function to create a treatment outcome curve showing probability of response
function createTreatmentOutcomeCurve() {
    // Get data points from all studies
    if (appState.allTrialOutcomes.length === 0) return;
    
    // Find response rate outcomes across all studies
    const responseData = [];
    
    appState.allTrialOutcomes.forEach(study => {
        study.outcomes.forEach(outcome => {
            const titleLower = outcome.title.toLowerCase();
            const isResponseOutcome = titleLower.includes(">= 50% improvement") || 
                                    titleLower.includes("responders") || 
                                    titleLower.includes("response rate");
            
            if (isResponseOutcome && outcome.measurements && outcome.measurements.length > 0) {
                // Extract drug name
                const drugName = extractDrugName(study.title, outcome.measurements);
                
                // Get experimental and control measurements
                const experimentalMeasurements = outcome.measurements.filter(m => !m.isControlGroup);
                const controlMeasurements = outcome.measurements.filter(m => m.isControlGroup);
                
                if (experimentalMeasurements.length > 0) {
                    // For response outcomes, measurements are usually percentages
                    experimentalMeasurements.forEach(measurement => {
                        responseData.push({
                            drug: drugName,
                            studyId: study.nctId,
                            phase: study.phase,
                            isControl: false,
                            responseRate: measurement.value
                        });
                    });
                }
                
                if (controlMeasurements.length > 0) {
                    controlMeasurements.forEach(measurement => {
                        responseData.push({
                            drug: "Placebo",
                            studyId: study.nctId,
                            phase: study.phase,
                            isControl: true,
                            responseRate: measurement.value
                        });
                    });
                }
            }
        });
    });
    
    if (responseData.length === 0) return;
    
    console.log(`Found ${responseData.length} response rate data points across all studies`);
    
    // Create a section for this visualization
    let outcomeCurveSection = document.getElementById('outcomeCurveSection');
    if (!outcomeCurveSection) {
        const drugSuccessSection = document.getElementById('drugSuccessSection');
        if (!drugSuccessSection) return;
        
        // Create section before the drug success section
        outcomeCurveSection = document.createElement('section');
        outcomeCurveSection.id = 'outcomeCurveSection';
        outcomeCurveSection.className = 'hidden mb-6';  // Start hidden until we add content
        outcomeCurveSection.innerHTML = `
            <div class="bg-white rounded-lg shadow-md p-6">
                <h2 class="text-xl font-semibold mb-4">Treatment Outcome Curve</h2>
                <p class="text-sm text-gray-600 mb-4">Combined visualization of treatment response rates across all trials.</p>
                <div class="mb-6">
                    <h3 class="text-lg font-medium mb-3">Response Rate Distribution</h3>
                    <div class="h-72">
                        <canvas id="treatmentOutcomeCurveChart"></canvas>
                    </div>
                </div>
                <div class="mb-6">
                    <h3 class="text-lg font-medium mb-3">Treatment vs Placebo Response</h3>
                    <div class="h-72">
                        <canvas id="treatmentVsPlaceboChart"></canvas>
                    </div>
                </div>
            </div>
        `;
        
        drugSuccessSection.parentNode.insertBefore(outcomeCurveSection, drugSuccessSection);
        
        // Add references to the elements object
        elements.outcomeCurveSection = outcomeCurveSection;
    }
    
    // Show the section
    showSection(elements.outcomeCurveSection, true);
    
    try {
        // Create the charts
        createTreatmentOutcomeCurveChart(responseData);
        createTreatmentVsPlaceboChart(responseData);
    } catch (error) {
        console.error("Error creating treatment outcome charts:", error);
        
        // Add error message to section
        outcomeCurveSection.querySelector('.bg-white').innerHTML += `
            <div class="bg-red-50 text-red-700 p-4 rounded-lg mt-4">
                <p>Error creating treatment outcome charts: ${error.message}</p>
                <p class="text-sm mt-2">This is likely due to insufficient response rate data in the available studies.</p>
            </div>
        `;
    }
}
function createTreatmentOutcomeCurveChart(responseData) {
    const canvas = document.getElementById('treatmentOutcomeCurveChart');
    if (!canvas) return;
    
    // Clear any previous chart
    if (charts.treatmentOutcomeCurve) {
        charts.treatmentOutcomeCurve.destroy();
    }
    
    // Group data by drug
    const drugGroups = {};
    responseData.forEach(item => {
        if (!drugGroups[item.drug]) {
            drugGroups[item.drug] = [];
        }
        drugGroups[item.drug].push(item.responseRate);
    });
    
    // Generate curves for each drug
    const datasets = [];
    Object.entries(drugGroups).forEach(([drug, rates], index) => {
        if (rates.length < 2) return; // Need at least 2 data points
        
        // Calculate mean and standard deviation
        const mean = calculateMean(rates);
        const stdDev = calculateStandardDeviation(rates, mean);
        
        // Generate curve data
        const curveData = [];
        for (let x = 0; x <= 100; x += 1) { // 0-100% response rate
            const density = (1 / (stdDev * Math.sqrt(2 * Math.PI))) * 
                          Math.exp(-Math.pow(x - mean, 2) / (2 * Math.pow(stdDev, 2)));
            curveData.push({x, y: density});
        }
        
        // Add dataset
        datasets.push({
            label: drug,
            data: curveData,
            borderColor: getColorByIndex(index),
            backgroundColor: getColorByIndex(index, 0.1),
            fill: true,
            tension: 0.4,
            pointRadius: 0
        });
    });
    
    const ctx = canvas.getContext('2d');
    
    // Create the chart
    charts.treatmentOutcomeCurve = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'linear',
                    min: 0,
                    max: 100,
                    title: {
                        display: true,
                        text: 'Response Rate (%)'
                    }
                },
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Probability Density'
                    }
                }
            },
            plugins: {
                legend: {
                    position: 'top'
                },
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            return `${context[0].dataset.label}`;
                        },
                        label: function(context) {
                            return `Response Rate: ${context.parsed.x.toFixed(1)}%`;
                        }
                    }
                }
            }
        }
    });
}

function createTreatmentVsPlaceboChart(responseData) {
    const canvas = document.getElementById('treatmentVsPlaceboChart');
    if (!canvas) return;
    
    // Clear any previous chart
    if (charts.treatmentVsPlacebo) {
        charts.treatmentVsPlacebo.destroy();
    }
    
    // Separate treatment and placebo data
    const treatmentData = responseData.filter(item => !item.isControl);
    const placeboData = responseData.filter(item => item.isControl);
    
    if (treatmentData.length === 0 || placeboData.length === 0) {
        canvas.parentElement.innerHTML = '<p class="text-center text-gray-500 py-8">Insufficient data for treatment vs placebo comparison.</p>';
        return;
    }
    
    // Calculate statistics
    const treatmentRates = treatmentData.map(item => item.responseRate);
    const placeboRates = placeboData.map(item => item.responseRate);
    
    const treatmentMean = calculateMean(treatmentRates);
    const placeboMean = calculateMean(placeboRates);
    
    const treatmentStdDev = calculateStandardDeviation(treatmentRates, treatmentMean);
    const placeboStdDev = calculateStandardDeviation(placeboRates, placeboMean);
    
    const treatmentCI = calculateConfidenceInterval(treatmentMean, treatmentStdDev, treatmentRates.length);
    const placeboCI = calculateConfidenceInterval(placeboMean, placeboStdDev, placeboRates.length);
    
    const ctx = canvas.getContext('2d');
    
    // Create the chart
    charts.treatmentVsPlacebo = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: ['All Treatments', 'Placebo'],
            datasets: [{
                label: 'Average Response Rate',
                data: [treatmentMean, placeboMean],
                backgroundColor: ['rgba(59, 130, 246, 0.7)', 'rgba(156, 163, 175, 0.7)'],
                borderColor: ['rgb(59, 130, 246)', 'rgb(156, 163, 175)'],
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Response Rate (%)'
                    },
                    max: 100
                }
            },
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            return context[0].label;
                        },
                        label: function(context) {
                            const index = context.dataIndex;
                            const label = context.dataset.label;
                            if (index === 0) { // Treatment
                                return [
                                    `${label}: ${treatmentMean.toFixed(1)}%`,
                                    `95% CI: [${treatmentCI.lower.toFixed(1)}, ${treatmentCI.upper.toFixed(1)}]`,
                                    `N = ${treatmentRates.length} data points`
                                ];
                            } else { // Placebo
                                return [
                                    `${label}: ${placeboMean.toFixed(1)}%`,
                                    `95% CI: [${placeboCI.lower.toFixed(1)}, ${placeboCI.upper.toFixed(1)}]`,
                                    `N = ${placeboRates.length} data points`
                                ];
                            }
                        }
                    }
                }
            }
        },
        plugins: [{
            id: 'errorBars',
            afterDatasetsDraw: function(chart) {
                const ctx = chart.ctx;
                
                chart.data.datasets.forEach((dataset, i) => {
                    const meta = chart.getDatasetMeta(i);
                    
                    if (!meta.hidden) {
                        meta.data.forEach((element, index) => {
                            // Error bars data
                            let plus, minus;
                            if (index === 0) { // Treatment
                                plus = treatmentCI.upper - treatmentMean;
                                minus = treatmentMean - treatmentCI.lower;
                            } else { // Placebo
                                plus = placeboCI.upper - placeboMean;
                                minus = placeboMean - placeboCI.lower;
                            }
                            
                            const x = element.x;
                            const y = element.y;
                            const barWidth = 5;
                            
                            // Save state
                            ctx.save();
                            
                            // Line style
                            ctx.lineWidth = 2;
                            ctx.strokeStyle = dataset.borderColor[index];
                            
                            // Draw the line
                            ctx.beginPath();
                            ctx.moveTo(x, y - plus);
                            ctx.lineTo(x, y + minus);
                            ctx.stroke();
                            
                            // Draw the top cap
                            ctx.beginPath();
                            ctx.moveTo(x - barWidth, y - plus);
                            ctx.lineTo(x + barWidth, y - plus);
                            ctx.stroke();
                            
                            // Draw the bottom cap
                            ctx.beginPath();
                            ctx.moveTo(x - barWidth, y + minus);
                            ctx.lineTo(x + barWidth, y + minus);
                            ctx.stroke();
                            
                            // Restore state
                            ctx.restore();
                        });
                    }
                });
            }
        }]
    });
}

function ensureChartCanvasesExist() {
    // Make sure the collated outcomes section is visible
    const collatedSection = document.getElementById('collatedOutcomesSection');
    if (!collatedSection) {
        console.error('Collated outcomes section not found');
        return;
    }
    
    // Find containers for charts or create them
    const chartContainers = collatedSection.querySelectorAll('.h-72');
    
    if (chartContainers.length < 3) {
        console.warn('Chart containers not found, attempting to create them');
        
        // Find the main content div
        const contentDiv = collatedSection.querySelector('.bg-white');
        if (!contentDiv) {
            console.error('Content div not found in collated outcomes section');
            return;
        }
        
        // Create containers if needed
        if (chartContainers.length === 0) {
            console.log('Creating all chart containers');
            // Create first section - Overall Treatment Effect
            const section1 = document.createElement('div');
            section1.className = 'mb-6';
            section1.innerHTML = `
                <h3 class="text-lg font-medium mb-3">Overall Treatment Effect Distribution</h3>
                <div class="flex justify-between mb-4">
                    <div>
                        <select id="outcomeMetricSelector" class="p-2 border border-gray-300 rounded-lg">
                            <!-- Will be populated dynamically -->
                        </select>
                    </div>
                    <div>
                        <select id="outcomeTypeSelector" class="p-2 border border-gray-300 rounded-lg">
                            <option value="all">All Outcomes</option>
                            <option value="primary" selected>Primary Outcomes</option>
                            <option value="secondary">Secondary Outcomes</option>
                        </select>
                    </div>
                </div>
                <div class="h-72">
                    <canvas id="overallTreatmentEffectChart"></canvas>
                </div>
            `;
            contentDiv.appendChild(section1);
            
            // Create second section - Phase Comparison
            const section2 = document.createElement('div');
            section2.className = 'mb-6';
            section2.innerHTML = `
                <h3 class="text-lg font-medium mb-3">Phase Comparison</h3>
                <p class="text-sm text-gray-600 mb-4">Compare effect sizes across different clinical trial phases. Higher values indicate better outcomes.</p>
                <div class="h-72">
                    <canvas id="phaseComparisonChart"></canvas>
                </div>
            `;
            contentDiv.appendChild(section2);
            
            // Create third section - Comparative Phase Performance
            const section3 = document.createElement('div');
            section3.className = 'mb-6';
            section3.innerHTML = `
                <h3 class="text-lg font-medium mb-3">Comparative Phase Performance</h3>
                <p class="text-sm text-gray-600 mb-4">Direct comparison of phase-specific effect sizes with confidence intervals.</p>
                <div class="h-72">
                    <canvas id="phasePerformanceChart"></canvas>
                </div>
            `;
            contentDiv.appendChild(section3);
            
            // Update element references
            elements.outcomeMetricSelector = document.getElementById('outcomeMetricSelector');
            elements.outcomeTypeSelector = document.getElementById('outcomeTypeSelector');
            
            // Re-add event listeners
            if (elements.outcomeMetricSelector) {
                elements.outcomeMetricSelector.addEventListener('change', () => {
                    appState.currentOutcomeMetric = elements.outcomeMetricSelector.value;
                    displayCollatedOutcomes();
                });
            }
            
            if (elements.outcomeTypeSelector) {
                elements.outcomeTypeSelector.addEventListener('change', () => {
                    appState.currentOutcomeType = elements.outcomeTypeSelector.value;
                    displayCollatedOutcomes();
                });
            }
        } else {
            // Add missing containers as needed
            const lastContainer = chartContainers[chartContainers.length - 1];
            const parentElement = lastContainer.parentElement;
            
            if (chartContainers.length === 1) {
                // Need to add phase comparison and performance sections
                const section2 = document.createElement('div');
                section2.className = 'mb-6';
                section2.innerHTML = `
                    <h3 class="text-lg font-medium mb-3">Phase Comparison</h3>
                    <p class="text-sm text-gray-600 mb-4">Compare effect sizes across different clinical trial phases. Higher values indicate better outcomes.</p>
                    <div class="h-72">
                        <canvas id="phaseComparisonChart"></canvas>
                    </div>
                `;
                parentElement.parentElement.insertBefore(section2, parentElement.nextSibling);
                
                const section3 = document.createElement('div');
                section3.className = 'mb-6';
                section3.innerHTML = `
                    <h3 class="text-lg font-medium mb-3">Comparative Phase Performance</h3>
                    <p class="text-sm text-gray-600 mb-4">Direct comparison of phase-specific effect sizes with confidence intervals.</p>
                    <div class="h-72">
                        <canvas id="phasePerformanceChart"></canvas>
                    </div>
                `;
                parentElement.parentElement.insertBefore(section3, section2.nextSibling);
            } else if (chartContainers.length === 2) {
                // Need to add phase performance section
                const section3 = document.createElement('div');
                section3.className = 'mb-6';
                section3.innerHTML = `
                    <h3 class="text-lg font-medium mb-3">Comparative Phase Performance</h3>
                    <p class="text-sm text-gray-600 mb-4">Direct comparison of phase-specific effect sizes with confidence intervals.</p>
                    <div class="h-72">
                        <canvas id="phasePerformanceChart"></canvas>
                    </div>
                `;
                parentElement.parentElement.insertBefore(section3, parentElement.nextSibling);
            }
        }
    }
    
    // Ensure chart canvases exist within containers
    const chartCanvases = [
        { id: 'overallTreatmentEffectChart', containerIndex: 0 },
        { id: 'phaseComparisonChart', containerIndex: 1 },
        { id: 'phasePerformanceChart', containerIndex: 2 }
    ];
    
    const updatedContainers = collatedSection.querySelectorAll('.h-72');
    chartCanvases.forEach(({ id, containerIndex }) => {
        if (containerIndex < updatedContainers.length) {
            const container = updatedContainers[containerIndex];
            if (!document.getElementById(id)) {
                console.log(`Creating canvas: ${id}`);
                container.innerHTML = `<canvas id="${id}"></canvas>`;
            }
        }
    });
}


// Function to copy data from trial to clipboard 
function copyTrialDataToClipboard(nctId) {
    const study = appState.studies.find(s => s.protocolSection?.identificationModule?.nctId === nctId);
    if (!study) return;
    
    const studyDetail = appState.studyDetails[nctId];
    
    const identification = study.protocolSection?.identificationModule || {};
    const design = study.protocolSection?.designModule || {};
    
    // Create a text summary of the study
    let summary = `CLINICAL TRIAL SUMMARY\n`;
    summary += `===================\n\n`;
    summary += `TITLE: ${identification.briefTitle || 'N/A'}\n`;
    summary += `NCT ID: ${nctId}\n`;
    summary += `PHASE: ${formatPhase(design.phases?.[0] || 'N/A')}\n`;
    summary += `STATUS: ${study.protocolSection?.statusModule?.overallStatus || 'N/A'}\n`;
    summary += `SPONSOR: ${identification.organization?.fullName || 'N/A'}\n\n`;
    
    // Add outcome data if available
    if (studyDetail && studyDetail.resultsSection?.outcomeMeasuresModule?.outcomeMeasures) {
        const outcomes = studyDetail.resultsSection.outcomeMeasuresModule.outcomeMeasures;
        
        summary += `OUTCOMES:\n`;
        outcomes.forEach((outcome, idx) => {
            summary += `${idx + 1}. ${outcome.title} (${outcome.type})\n`;
            summary += `   Time Frame: ${outcome.timeFrame || 'Not specified'}\n`;
            
            if (outcome.classes && outcome.classes[0]?.categories) {
                outcome.classes.forEach(cls => {
                    cls.categories.forEach(cat => {
                        summary += `   - ${cat.title}:\n`;
                        
                        cat.measurements.forEach(measurement => {
                            const group = outcome.groups.find(g => g.id === measurement.groupId);
                            if (group) {
                                summary += `     * ${group.title}: ${measurement.value}`;
                                if (measurement.dispersion) {
                                    summary += ` ± ${measurement.dispersion} (${measurement.dispersionType || 'dispersion'})`;
                                }
                                summary += `\n`;
                            }
                        });
                    });
                });
            }
            summary += `\n`;
        });
    }
    
    // Add URL to the full study
    summary += `View full study: https://clinicaltrials.gov/study/${nctId}\n`;
    
    // Create a temporary textarea element to copy the text
    const textarea = document.createElement('textarea');
    textarea.value = summary;
    document.body.appendChild(textarea);
    textarea.select();
    
    try {
        const successful = document.execCommand('copy');
        const msg = successful ? 'successful' : 'unsuccessful';
        console.log('Copy trial data was ' + msg);
        alert('Study details copied to clipboard');
    } catch (err) {
        console.error('Error copying trial data: ', err);
        alert('Failed to copy study details');
    }
    
    document.body.removeChild(textarea);
}
        function initEventListeners() {
            elements.searchButton.addEventListener('click', handleSearch);
            elements.phaseFilter.addEventListener('click', handlePhaseFilter);
            elements.closeStudyDetail.addEventListener('click', () => {
                showSection(elements.studyDetailSection, false);
            });
            
            // Add enter key support for search
            elements.drugSearch.addEventListener('keyup', event => {
                if (event.key === 'Enter') {
                    handleSearch();
                }
            });
            elements.conditionSearch.addEventListener('keyup', event => {
                if (event.key === 'Enter') {
                    handleSearch();
                }
            });
            
            // Add outcome metric selector event
            elements.outcomeMetricSelector.addEventListener('change', () => {
                appState.currentOutcomeMetric = elements.outcomeMetricSelector.value;
                displayCollatedOutcomes();
            });
            
            // Add outcome type selector event
            elements.outcomeTypeSelector.addEventListener('change', () => {
                appState.currentOutcomeType = elements.outcomeTypeSelector.value;
                displayCollatedOutcomes();
            });

            const navbar = document.createElement('div');
    navbar.className = 'fixed bottom-4 left-0 right-0 flex justify-center';
    navbar.innerHTML = `
           <div class="bg-white rounded-full shadow-lg px-4 py-2 flex space-x-4">
                <button id="nav-studies" class="text-primary hover:text-blue-700 text-sm font-medium">Studies</button>
                <button id="nav-outcomes" class="text-primary hover:text-blue-700 text-sm font-medium">Outcomes</button>
                <button id="nav-aggregate" class="text-primary hover:text-blue-700 text-sm font-medium">Aggregate</button>
                <button id="nav-drug-success" class="text-primary hover:text-blue-700 text-sm font-medium">Success Rates</button>
                <button id="nav-fda" class="text-primary hover:text-blue-700 text-sm font-medium">FDA Data</button>
            </div>
    `;
    document.body.appendChild(navbar);
    
    // Add event listeners for navigation
    document.getElementById('nav-studies').addEventListener('click', () => {
        elements.studiesSection.scrollIntoView({ behavior: 'smooth' });
    });
    document.getElementById('nav-outcomes').addEventListener('click', () => {
        elements.collatedOutcomesSection.scrollIntoView({ behavior: 'smooth' });
    });
    document.getElementById('nav-aggregate').addEventListener('click', () => {
        elements.aggregateOutcomesSection.scrollIntoView({ behavior: 'smooth' });
    });
    document.getElementById('nav-fda').addEventListener('click', () => {
        elements.fdaDataSection.scrollIntoView({ behavior: 'smooth' });
    });
    document.getElementById('nav-drug-success')?.addEventListener('click', () => {
        elements.drugSuccessSection.scrollIntoView({ behavior: 'smooth' });
    });
    

            
            // Handle window resize to redraw charts
            window.addEventListener('resize', debounce(() => {
                // Only redraw visible charts to improve performance
                const redrawCharts = () => {
                    Object.values(charts).forEach(chart => {
                        if (chart && typeof chart.update === 'function') {
                            try {
                                chart.resize();
                                chart.update();
                            } catch (e) {
                                console.warn('Error updating chart:', e);
                            }
                        }
                    });
                };
                
                redrawCharts();
            }, 250));
        }
        
        // Utility function for debouncing
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Initialize application
        function init() {
    // Check if all required elements are available
    const missingElements = Object.entries(elements).filter(([key, value]) => !value);
    if (missingElements.length > 0) {
        console.error('Missing required elements:', missingElements.map(([key]) => key));
        
        // Try to get elements again after DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            Object.keys(elements).forEach(key => {
                if (!elements[key]) {
                    elements[key] = document.getElementById(key);
                }
            });
            
            initEventListeners();
        });
    } else {
        initEventListeners();
    }
    
    // Set default condition
    if (elements.conditionSearch) {
        elements.conditionSearch.value = "Treatment Resistant Depression";
    }
    
    console.log('Enhanced TRD Clinical Trials Research Tool initialized');
}



// Clinical Trial Dashboard Module
// Robust Clinical Trial Dashboard Module


  document.addEventListener('DOMContentLoaded', () => {
    const trialSelect = document.getElementById('trial-selection');
    const visualizeBtn = document.getElementById('visualize-btn');
    const loadingIndicator = document.getElementById('loading-indicator');
    const visualizationContainer = document.getElementById('visualization-container');
    

    
    // Event listener for visualize button
    visualizeBtn.addEventListener('click', async () => {

      // Show loading indicator
      loadingIndicator.style.display = 'block';
      visualizationContainer.innerHTML = '';
      
      try {
        // Call backend to fetch trial data and generate visualization
        const result = await generateTrialVisualization();
        console.log(result)
        
        // Insert the generated HTML into the container
        let htmlContent = result.html;
    
    // Remove the outer quotes if they exist
    if (htmlContent.startsWith('"') && htmlContent.endsWith('"')) {
      htmlContent = htmlContent.slice(1, -1);
    }
    
    // Replace escaped newlines and quotes
    htmlContent = htmlContent.replace(/\\n/g, '\n').replace(/\\"/g, '"');
    
    // Extract script content
    const scriptTagMatch = htmlContent.match(/<script>([\s\S]*?)<\/script>/);
    let scriptContent = '';
    
    if (scriptTagMatch && scriptTagMatch[1]) {
      scriptContent = scriptTagMatch[1];
      // Remove the script tag from the HTML so we can add it properly
      htmlContent = htmlContent.replace(/<script>[\s\S]*?<\/script>/, '');
    }
    
    // Insert the HTML
    visualizationContainer.innerHTML = htmlContent;
    
    // Create and execute the script
    if (scriptContent) {
      const script = document.createElement('script');
      script.textContent = scriptContent;
      document.body.appendChild(script);
    }
    
    // If there's separate JavaScript returned as well, execute it too
    if (result.javascript) {
      const script = document.createElement('script');
      script.textContent = result.javascript;
      document.body.appendChild(script);
    }
    
  } catch (error) {
    console.error('Error generating visualization:', error);
    visualizationContainer.innerHTML = `
      <div class="p-4 bg-red-100 text-red-700 rounded">
        Error generating visualization: ${error.message}
      </div>
    `;
  } finally {
    // Hide loading indicator
    loadingIndicator.style.display = 'none';
  }
})
})

  // Function to call the backend
  async function generateTrialVisualization() {
    console.log( appState.allTrialOutcomes)
    a =  appState.allTrialOutcomes
    
    const response = await fetch('http://localhost:3000/api/generate-visualization', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({  
        trialData: a 
    })
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Failed to generate visualization');
    }
    
    return await response.json();
  }


  init()
    </script>
</body>
</html>